[TOC]

# JVM概述

## JVM原理

下图就展示了java的一次编译,到处运行

![img](.img/.JVM/352511-20170810232429980-107444580.png)

Java程序经过一次编译之后,将java代码编译为字节码也就是class文件,然后在不同的操作系统上依靠不同的java虚拟机进行解释,最后在转换为不同平台的机器码,最终得到执行;

## 一个普通的java代码的执行过程

一个HelloWorld类

```java
public class HelloWorld{
    public static void main(String[] args){
        System.out.print("Hello world");
    }
}
```

下面是JVM将HelloWorld类加载并执行的过程,如图所示:

![img](.img/.JVM/352511-20170810232431105-2080375000.png)

java代码通过编译之后生成字节码文件(class文件),通过:`java HelloWorld`命令执行后,此时java根据系统版本找到jvm.cfg

> 该文件一般位于`C:\Program Files\Java\jdk1.8.0_101\jre\lib\amd64\jvm.cfg`路径下
>
> ![img](.img/.JVM/352511-20170810232432183-490667295.png)

其中-server KNOWN就标识名称为server的jvm可用; 如果这时你搜索你电脑上的jvm.dll,你就会发现它一定在你的某个server目录下,比如我的`C:\Program Files\Java\jdk1.8.0_101\jre\bin\server\jvm.dll`; 简而言之就是通过jvm.cfg文件找到对应的jvm.dll(jvm.dll是java虚拟机的主要实现),然后进行初始化JVM,并获取JNI接口

> JNI接口就是java本地接口,它可以从硬盘中找到对应的class文件并将其装载到jvm中(它还常用于java与操作系统和硬件交互)

通过JNI接口找到class文件并装载进JVM,然后找到mian方法,最后执行

## JVM的生命周期

### JVM实例

一个运行时的java虚拟机负责运行一个java程序

当启动一个java程序时,一个虚拟机实例诞生, 当程序关闭退出,这个虚拟机实例也随之消亡

如果在同一台计算机上同时运行多个java程序,将得到多个java虚拟机实例,每个java程序都运行于它自己的虚拟机实例中

### 生命周期

1. JVM创建

   当启动一个java程序时,一个JVM实例就产生了,任何一个拥有main函数的class都可以作为JVM实例运行的起点

2. JVM运行

   main()作为程序初始线程的起点,任何其他线程均由该主线程启动; JVM内部有两种线程: 守护线程和非守护线程; 主线程属于非守护线程,守护线程通常由JVM自己使用

3. JVM消亡

   当程序中的所有非守护线程都终止时,JVM才退出; 若安全管理器允许,程序也可以使用java.lang.Runtime类或者java.lang.System.exit()来退出

## JVM各区域潜在的异常

- PC寄存器

  此区域是JVM规范中唯一一个不存在OutOfMemory的区域。

- java栈

  1. StackOverflowError ：栈深度大于虚拟机所允许的深度。

  2. OutOfMemory：如果虚拟机栈可以动态扩展（当前大部分Java虚拟机都可以动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展是无法申请到足够的内存

- 本地方法栈
  1. StackOverflowError ：栈深度大于虚拟机所允许的深度。
  2. OutOfMemory

- java堆
  
1. OutOfMemory: 堆无法扩展时

- 方法区
  
  1. OutOfMemory: 超出内存容量

# JVM基本结构

## 结构图

![img](.img/.JVM/352511-20170810232433277-922435213.png)

主要分为三大类:

1. 类装载器(ClassLoader)
2. 执行引擎
3. 内存空间(方法区,java堆,java栈,本地方法栈,PC寄存器)

## 类装载器ClassLoader

### 类加载机制

JVM把字节码.class文件加载到内存,并对数据进行校验,转换解析和初始化,最终形成可以被虚拟机直接使用的java对象,这就是虚拟机的类加载机制

### 类加载器

类从被加载到虚拟机内存中开始,到卸载出内存为止,它的生命周期包括了:加载(Loading),验证(Verification),准备(Preparation),解析(Resolution),初始化(Initialization),使用(Useing),卸载(Unloading)七个阶段,其中验证,准备,解析三个部分统称为链接

![img](.img/.JVM/20180517171259199.png)

1. 加载(重点)

   加载阶段通常也被称为"装载",主要完成:

   1. 通过"全类名"来获取定义此类的二进制字节流
   2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
   3. 在java堆中生成一个代表这个类的java.lang.Class对象,作为方法区这些数据的访问入口

   加载阶段(即加载阶段中获取类的二进制字节流的动作)是开发期可控性最强的阶段,因为加载阶段可以使用系统提供的类加载器(ClassLoader)来完成,也可以有用户自定义的类加载器完成,开发人员可以通过定义自己的类加载器区控制字节流的获取方法

   加载阶段完成后,虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在**方法区**之中,方法区中的数据存储格式有虚拟机实现自行定义,虚拟机并未规定此区域的具体数据结构,**然后在java堆中实例化一个java.lang.Class类的对象,这个对象作为程序访问方法区中的这些类型数据的外部接口**

2. 验证(了解)

   验证是链接阶段的第一步,这一步主要的目的是确保class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身安全

   验证阶段主要包括四个检验过程: 文件个是验证,元数据验证,字节码验证和符号引用验证

3. 准备(了解)

   准备阶段是正式的**为变量分配内存并设置类变量初始值**的阶段,这些内存都将在**方法区**中进行分配,这个阶段中有两个容易产生混淆的知识点,首先进行内存分配的是类变量(static修饰的变量),不包括实例变量,实例变量将会在对象实例化是随着对象一起分配在**java堆**中; 其次是这里所说的初始值"通常情况"下是数据类型的零值

   假如一个类变量定义为:`public static int value=12;`

   那么变量value在准备阶段过后的初始值为0而不是12,因为这时候尚未开始执行任何java方法,而把value赋值为12的putstatic指令是程序编译后,存放在类构造器`<clinit>()`方法之中,所以把value赋值为12的动作将在初始化阶段才会被执行

   上面所说的"通常情况"下初始值是零值,那么相对于一些特殊的情况,如果类字段的字段属性表中存在ConstantValue属性,那么在准备阶段value就会被初始化为ConstantValue属性所指定的值,假设上面的类变量value定义为:`public static final int value=123;`

   编译时javac会将为value生成ConstantValue属性,在准备阶段虚拟机就会根据ConstantValue的设置将value设置为123

4. 解析(了解)

   解析阶段是虚拟机常量池内的符号引用替换为直接引用的过程

   符号引用: 符号引用是一组符号来描述所引用的目标对象,符号可以是任何形式的字面量,只要使用时能无歧义的定位到目标即可; 符号引用与虚拟机实现的内存布局无关,引用的目标对象并不一定已经加载到内存中

   直接引用: 直接引用可以是直接指向目标对象的指针,相对偏移量或是一个能间接定位到目标的句柄; 直接引用是与虚拟机内存布局实现相关的,同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同,如果有了直接引用,那么引用的目标必须顶已经在内存中存在

   解析的动作主要针对类或接口,字段,类方法,接口方法四类符号引用进行; 分别对应编译后常量池内的CONSTANT_Class_Info(类,接口的解析)、CONSTANT_Fieldref_Info(字段解析)、CONSTANT_Methodef_Info(类方法解析)、CONSTANT_InterfaceMethoder_Info(接口方法解析)四种常量类型

5. 初始化(了解)

   类加载最后阶段,若该类具有超类,则对其进行初始化,执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的static变量将会在这个节点赋值,成员变量也将被初始化)

6. 使用

7. 卸载

总结:

类加载器的任务是根据一个类的全限定类名来读取此类的二进制字节流到JVM中,然后转换为一个与目标类对应的java.lang.Class对象实例,在虚拟机提供了人中类加载器: 

1. 启动类加载器(BootStrap ClassLoader)

   这个类加载器负责加载放在`%JAVA_HOME%\lib`目录下的或者被-Xbootclasspath参数所指定的路径中的,并且是虚拟机识别的类库,用户无法直接使用

2. 扩展类加载器(Extension ClassLoader)

   这个类加载器由sun.misc.Launcher$AppClassLoader实现,它负责`%JAVA_HOME%\lib\ext`目录下的或者被java.ext.dirs系统变量所指定的路径中的所有类库,用户可以直接使用

3. 应用类加载器(Application ClassLoader)

   这个类由sun.misc.Launcher$ApClassLoader是实现,是CLassLoader中getSystemClassLoader()方法的返回值; 它负责用户路径ClassPath所指定的类库,用户可以直接使用,如果胡勇没有自定定义类加载器,默认使用这个

4. 自定义类加载器(User ClassLoader)

   用户自己定义的类加载器

### 双亲委派模型

![img](.img/.JVM/2350cd2c7e48a6dc.png)

双亲委派模型是一种组织类加载器之间关系的一种规范,它的工作原理是:

- 如果一个类加载的请求,它不会自己去尝试加载这个类,而是把这个请求委派给父类加载器去完成,这样层层递进,最终所有的加载请求都会传到最顶层的启动类加载器中,只有当父类加载器无法完成这个加载请求时(即它的搜索范围没有找到对应的类),才会交给子类加载器去尝试加载

## 执行引擎

执行引擎负责具体的代码调用即执行过程; 就目前而言,所有的引擎基本一致:

1. 输入: 字节码文件
2. 处理: 字节码解析
3. 输出: 执行结果

物理机的执行引擎是由硬件实现的,和物理机的执行过程不同的是虚拟机的执行是自己实现的

---

类装载器负责装载编译后的字节码,并加载到运行时数据区(Runtime Data Area),然后执行引擎会执行这些字节码; 通过类装载器装载的且被分配到JVM的运行时数据区的字节码会被执行引擎执行,执行引擎以指令为单位读取java字节码,它就向一个cpu一样,一条一条的执行机器指令,每个字节码指令由一个1字节的操作码和附加的操作数组成,执行引擎取得一个操作码,然后根据操作数来执行任务,完成后就继续执行下一条操作码; 不过java字节码是用一种人类可以读懂的语言编写的,而不是用机器语言;因此,执行引擎必须把字节码转换成可以直接被JVM执行的语言,字节码可以通过以下两种凡是转换成合适的语言:

1. 解释器

   一条一条的读取,解释并执行字节码指令,因为它是一条一条的解释和执行指令,所以它可以很快的解释字节码,但是执行起来会比较慢,这是解释执行的语言的一个缺点; 

2. 即时编译器(Just-In-Time)

   即时编译器被引入用来弥补解释器的缺点; 执行引擎首先按照解释执行的方式来执行,然后在合适的时候,即时编译器把整段字节码编译成本地代码,然后,执行引擎就没有必要再去解释执行指令了,而是可以直接通过编译过的本地代码执行; 执行本地代码比一条一条进行解释执行的速度快很多; 编译后的代码可以执行的很快,因为本地代码时保存在缓存里的;

## 内存空间

JVM运行时会分配好方法区和java堆; 而JVM每遇到一个线程,就为其分配一个程序计数器,java栈,本地方法栈,当线程终止时,这三者所占用的内存空间也会释放掉

> 程序计数器,java栈,本地方法栈的生命周期与所属线程相同,而方法区和java堆的生命周期与java程序运行生命周期相同,所以gc只发生在线程共享的区域(大部分发生在Heap上)

### java堆(线程共享)

Java堆(Java Heap)是java虚拟机中内存最大的一块,Java堆在虚拟机启动时创建,被所有线程共享

作用: 存放对象实例; 垃圾收集器主要管理的就是java堆,java堆在物理上可以不连续,只要逻辑上连续即可

### 方法区(线程共享)

线程共享,用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等的数据

和java堆一样,不需要连续的内存,可以选择固定的大小,更可以选择不实现垃圾收集

### java栈(线程私有)

Java栈也被叫做虚拟机栈(Java Vitual Machine Stack),是线程私有的,生命周期与线程相同

虚拟机栈描述的是java方法执行的内存模型: 每个方法被执行的时候都会创建一个帧栈(Stack Frame),存储了:

1. 局部变量表
2. 操作数栈
3. 指向当前类的运行时常量池的引用
4. 方法的返回地址

每一个方法被调用直到方法执行完成的过程,就对应这一个栈帧在虚拟机栈中从入栈到出栈的过程

这个区域有两种异常情况:

1. StackOverflowError: 线程请求的栈深度大于虚拟机所允许的深度
2. OutOfMemoryError: 虚拟机栈扩展但无法申请足够的内存时

> - 局部变量表
>
>   用来存储方法中的局部变量(包括在方法中生命的非静态变量以及函数形参),对于基本数据类型的变量,则直接存储它的值,对于引用类型的变量,则存储指向对象的引用; 局部变量表的大小在编译器就可以确定其大小了,因此在程序执行期间局部变量表的大小是不会改变的
>
> - 操作数栈
>
>   栈最典型的一个应用就是用于对表达式求值; 在一个线程执行方法的过程中,实际上就是不断执行语句的过程,而归根结底就是进行计算的过程,因此可以这么说,程序中的所有计算过程都是借助于操作数栈来完成的
>
> - 指向运行时常量池的引用
>
>   因为在方法执行的过程中又可能需要用类中的常量,所以必须要有一个引用指向运行时常量
>
> - 方法返回值
>
>   当一个方法执行完毕之后,要返回之前调用它的地方,因此在栈帧中必须保存一个方法返回地址

> 运行时常量池
>
> 是方法区的一部分,保存Class文件中的符号引用,翻译出来的直接引用; 运行时常量池可以在运行期间将新的常量放入池中

### 本地方法栈(线程私有)

Java栈是为执行java方法服务的

而本地方法栈是为虚拟机使用到的Native方法服务(调用其他语言的函数库,如C等)

### 程序计数器(线程私有)

程序技术器是一块比较小的内存空间,可以看作是当前线程所执行字节码的行号指示器; 分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器完成

由于java虚拟机的多线程是通过线程轮流切换并分cpu时间片实现的,为了线程切换后能恢复到正确的执行位置,每条线程都需要一个独立的程序计数器,个线程之间的计数器互不影响,独立存储

1. 如果线程正在执行的是一个java方法,计数器记录的是正在执行的虚拟机字节码指令的地址
2. 入宫正在执行的是Native方法,这个计数器的值为空

程序计数器是唯一一个没有规定任何OutOfMemoryError 的区域

### Java中对象创建及访问的过程

基本上会涉及到java栈,java堆,方法区这三个最重要的内存区域

例如:

```java
Object obj =  new  Object();
```

首先对上述代码进行一个简单的说明:

1. 定义一个Object类型的变量obj,这个obj就是一个引用类型的变量,保存在java栈中
2. `new Object()`将会在java的堆内存中形成一块存储Object类型所有实例数据值的结构化内存

java中对象的访问流程如下:

1. 定义的对象名称保存在java栈的本地变量表
2. 通过本地变量表中的栈内存地址可以找到堆内存
3. 利用堆内存的对象进行本地方法的调用

这个过程中的引用类型变量在java虚拟机规范里面只规定了一个指向对象的引用地址,并没有定义这个引用应该通过哪种方式区定位,访问到java堆中的对象位置,因此不同的虚拟机实现的访问方式可能不同,主流的方式有两种: 使用句柄和直接指针

> 具体的详细解释参考链接: https://www.jianshu.com/p/dfe0b8ff54de

# 垃圾收集器(GC)

## JVM垃圾回收机制

GC的基本原理: 将内存中不再使用的对象进行回收,GC中用于回收的方法称为收集器,由于GC需要消耗一些资源和时间,java在对对象的生命周期特征及进行分析后,按照新生代,旧生代的方式对对象进行垃圾回收,以尽可能的缩短GC对应用造成的暂停

## 哪些内存需要回收

JVM的内存结构包括五大区域: 程序计数器,java栈,本地方法栈,Java堆,方法区; 其中程序计数器,虚拟机栈,本地方法栈3个区域会随着线程而生,随线程而灭,因此这几个区域的内存分配和回收都具备确定性,就不需要过多考虑回收的问题,因为方法结束或者线程结束时,内存自然就收回了;而java堆和方法区则不一样,这部分内存的分配和回收是动态的,正式垃圾收集器所需要关值的部分

## 如何判断是否需要收回

### 引用计数法

引用计数是垃圾收集器中的早期策略; 在这种方法中,堆中每个对象实例都有一个引用计数,当一个对象被创建时,就将该对象实例分配给一个变量,该变量计数设置为1;当任何其他变量被赋值为这个对象的引用时,计数+1(a=b,则b引用的对象实例的计数器+1),但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时,对象实例的引用计数器-1; 任何引用计数器为0的对象实例就可以被当做垃圾收集; 当一个对象实例被垃圾收集时,它引用的任何对象实例的引用计数器-1;

优点: 引用计数收集器可以很快的执行,交织在程序运行中; 对程序需要不被长时间打断的实时环境比较有利;

缺点: 无法检测出循环引用; 如父对象有一个对子对象的引用,子对象反过来引用父对象,这样,他们的引用计数永远不可能为0

### 可达性分析算法

程序把所有的引用关系看作一张图,从一个节点GC ROOTS开始,寻找对应的引用节点,找到这个节点以后,继续寻找这个节点的引用节点,当所有的引用节点寻找完毕之后,剩余的节点则被认为是没有被引用到的节点,即无用的节点,无用的节点将会被判定为是可回收的对象

在java语言中,可作为GC ROOTS的对象包括下面几种:

1. Java栈中的引用过的对象(帧栈中的本地变量表)
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI(Native方法)引用的对象

不同的对象引用类型,GC会采用不同的方法进行回收,JVM对象的引用分为四种类型:

1. 强引用

   在程序代码中普遍存在的,类似Object obj=new Object()这类引用,只要强引用还存在,垃圾收集器永远不会收回掉被引用的对象

2. 软引用

   用来描述一些还有用但并非必须的对象; 对于软引用关联着的对象,在系统将要发生内存溢出异常之前,将会把这些对象列进回收范围之间进行第二次回收; 如果这次回收后还没有足够的内存,才会抛出内存溢出异常

3. 弱引用

   也是用来描述非必须对象的,但是它的强度比软引用更弱一些,被弱引用关联的对象只能生存到下一次垃圾收集发生之前; 当垃圾收集器工作时,无论当前内存是否足够,都会收回掉只被弱引用关联的对象

4. 虚引用

   也叫幽灵引用或幻影引用（名字真会取，很魔幻的样子），是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知（用来得知对象是否被GC）

### 总结

无论引用计数算法还是可达性分析算法都是基于强引用而言的

即时在可达性分析算法中不可达的对象,也并非是"非死不可",这是他们暂时处于"缓刑"阶段,要正真宣告一个对象死亡,至少要经历两次标记过程

第一次标记: 如果对象在进行可达性分析后发现没有和GC Roots相连接的引用链,那它将会被第一次标记

第二次标记: 第一次标记后接着会进行一次筛选,筛选的条件是此对象是否有必要执行finalize()方法,在finalize()方法中没有重新与引用链建立关联关系的,将被进行第二次标记

第二次标记成功的对象将真的会被回收,如果对象在finalize()方法中重新与引用链建立了关联关系,那么将会逃离本次回收,继续存活

## 常用的垃圾回收算法

### 标记-清除算法(Mark-Sweep)

标记-清除算法分为两个阶段: 标记阶段和清除阶段; 标记阶段的任务时标记出所有需要被回收的对象,清除阶段就是回收被标记的对象所占用的空间

![img](.img/.JVM/20180526220654198.png)

主要缺点:

1. 效率问题,标记和清除过程的效率都不高
2. 空间问题,标记清除之后会产生大量不连续的内存碎片,空间碎片太多可能会导致: 当程序在以后的运行过程中需要分配较大对象时无法找到足够的内存而不得不提前发出另一次垃圾收集动作

### 复制算法(Copying)

为了解决标记-清除算法的缺陷,复制算法就被提出了;它将可用内存按容量划分为大小相等的两块,每次只是用其中的一块,当这一块的内存用完了,就将还存活着的对象复制到另外一块上面,然后再把已使用的内存空间一次性清理掉,这样就不容易出现内存碎片的问题

![img](.img/.JVM/2018052622072333.png)

这种算法虽然实现简单,运行高效且不容易产生内存碎片,但是却对内存空间的使用做出了高昂的代码,因为能够使用的内存缩减到原来的一半

很显然,复制算法的效率跟存活对象的数目的多少有很大的关系,如果存活对象很多,那么复制算法的效率会大大减低

### 标记-整理算法(Mark-Compact)

为了解决复制算法的缺陷,充分利用内存空间,提出了标记-这个能力算法; 该算法标记阶段和标记-清除算法一样,但是在完成标记之后,它不是直接清理可回收对象,而是将存活对象都向一端移动,然后清除掉另一端边界意外的内存

![img](.img/.JVM/20180526220855696.png)

### 分代收集算法(Generational Collection)

分代收集算法是目前大部分JVM的垃圾收集器采用的算法; 它的核心思想是根据对象存活的声明周期将内存划分为若干个不同的区域,一般情况下将堆区划分为老年代和新生代

老年代的特点是每次垃圾收集时只有少量对象需要被回收,而新生代的特点是每次垃圾回收时都有大量的对象需要被回收,那么就可以根据不同代的特点采取最合适的收集算法;

java堆对象的收回

- 新生代

  采用复制算法,新生代对象一般存活率较低,一般的,使用两块10%的内存作为活动区间(from)和空闲区间(to),而另外80%的内存区间(Eden),则是用来给新建对象分配内存的,一旦发生GC(发生GC的情况在下方解释),将10%的活动区间与另外80%中存活的对象转移到10%的空闲区间,接下来,将之前90%的内存全部释放,一次类推,下面用一张图来说明:

  ![img](.img/.JVM/20180518112244815.png)

  > 堆大小=新生代+老年代,新生代与来年代的比例为1:2,新生代细分为一块比较大的Eden空间和两块比较小的Survivor空间,分别被命名为from和to;

  绝大多数刚创建的对象会被分配到Eden区

  > Eden区是连续的内存空间,因此在其上分配内存极快,并且其中的大多数对象很快就会消亡

  当Eden区满的时候,执行Minor GC,将消亡的对象清理掉,并将剩余的对象复制到一个存活区from中(此时to是空白的,from和to总有一个是空白的),此后,每次Eden区满了,就执行一次Minor GC,并将剩余的对象添加到from区中,当from区也满的时候,将from区中仍然存活的对象直接复制都to区中,以后每当Eden区满了执行Minor GC后,就将剩余的对象添加to区(此时from区是空白的),当两个存活区切换了几次之后(HotSpot虚拟机默认15次,用`-XX:MaxTenuringThreshold`控制,大于该值进入老年代),仍然存活的对象将被复制到老年代

  从上面的过程可以看出,Eden区是连续的空间,且from和to区总有一个为空,经过一次GC和复制,from和to中的其中一个会保存着当前还存活的对象,而Eden区和另外一个Survior区的内容都不再需要了,可以直接清空,到下一次GC时,两个from和to的角色互换,因此,这种方式分配内存和清理内存的效率都极高,这种垃圾收集的方法就是复制算法(将Eden区和一个Survivor中任然存活的对象拷贝到另一个Survivor中)

- 老年代

  对象如果在年轻代存活了足够长的时间而没有被清理掉(级在几次Young GC后存活下来),则会被复制到老年代,老年代的空间比年轻代大,能存放更多的对象,在老年代上发生的GC次数也年轻代少;当老年代内存不足时,将执行Major GC,也叫Full GC;

  如果对象比较大(比如长字符串或大数组),年轻代的空间不足,则大对象会直接分配到老年代上(大对象可能触发提前GC,应该少用,更应该避免使用短命的大对象); 用`-XX:PretenureSizeThreshold`来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上

- 永久代

  在堆区之外还有一个永久代,它用来存储class类,常量,方法描述等,对永久代的回收主要是两部分内容: 废弃常量和无用的类

  对于常量的回收很简单,没有引用了就可以被回收,但对于无用的类进行回收,必须保证3点:

  1. 类的所有实例都已经被回收
  2. 加载类的ClassLoader已经被回收
  3. 类对象的Class对象没有被引用(即没有通过反射引用该类的地方)

  永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。HotSpot虚拟机提供`-Xnoclassgc`进行控制

## 常见的垃圾回收器

### Serial收集器(复制算法)

### Serial Old收集器(标记-整理算法)

### ParNew收集器(复制算法)

### Parallel Scavenge收集器(复制算法)

### Parallel Old收集器(标记-整理算法)

### CMS(Concurrent Mark Sweep)收集器(标记-清除算法)

### G1收集器



## GC的分类及健康状态

https://blog.csdn.net/mccand1234/article/details/52078645#Young_Generation_79

### YoungGC/MinorGC

回收Eden区

YoungGC是最频繁发生的,同时YoungGC的问题也是最难定位的,这里给出YoungGC的三种问题定位方法:

1. 查看服务器SWAP&IO情况,如果服务器发生Swap,会严重拖慢GC效率,导致STW时间异常长,拉长接口响应时间,从而影响用户体验
2. 查看StringTable情况
3. 排查每次YoungGC后幸存对象大小(JVM模型基于分配的对象朝生夕死的假设设计,如果每次YoungGC后幸存的对象较大,可能存在问题)

可参考的健康的GC状况给出建议YoungGC频率5秒/次，经验值3秒~6秒/次都是比较合理的:

- 如果YoungGC频率远高于这个值,例如例如20秒/次，30秒/次，甚至60秒/次,这种情况下,JVM相当空闲,处于基本上无事可做的状态,建议缩容,减少服务器浪费
- 如果YoungGC频率远低于这个值，例如1秒/次，甚至1秒/好多次,这种情况下,JVM相当繁忙,建议按照如下步骤进行初步诊断
  1. 检查新生代,Eden区在整个堆占比在25%~40%比较合理,如果太小,建议扩大Xmn
  2. 检查SurviorRatio,保持默认值8即可,Eden:S0:S1=8:1:1是一个比较合理的值

### OldGC

只单独回收老年代的只有CMS GC

触发CMS GC条件比较简单,JVM有一个线程定时扫描老年代,如果发现老年代占比超过参数`-XX:CMSInitiatingOccupancyFraction=75`设定值（CMS条件下默认为68%），就会触发CMS GC

> （定时时间设置`XX:CMSWaitDuration=2000`）（Old区占比设置：-`XX:CMSInitiatingOccupancyFraction=75`）（`-XX:+UseCMSInitiatingOccupancyOnly` 只有在Old区占比满足条件的情况下才触发CMS GC）

可参考的健康的GC状况给出建议CMS GC频率不超过1天/次，如果CMS GC频率1天发生数次，甚至上10次，说明你的GC情况病的不轻了，建议按照如下步骤进行初步症断：

1. 检查新生代和老年代的比值,尽量留60%以上的堆空间给老年代(一般为2/3)
2. 通过jstat查看每次YoungGC后晋升到老年代的对象占比,如果发现每次YoungGC后老年代涨好几个百分点，甚至上10个点，说明有大对象,建议dump（jmap -dump:format=b,file=app.bin pid）后用MAT分析；
3. 如果不停的CMS GC，Old区降不下去，建议先执行jmap -histo pid | head -n20 查看TOP20对象分布，如果除了[B和[C，即byte[]和char[]，还有其他占比较大的实例，如下图所示中TOP1的Object数组，也可通过dump后用MAT分析问题；
4. 如果TOP20对象中有StandartSession对象，排查你的业务代码中有没有显示使用HttpSession，例如String id = request.getSession().getId();，一般的OLTP系统几乎不会使用HttpSession，且HttpSession的的生命周期很长，会加快Old区增长速度；

### FullGC/MajorGC

回收整个java堆

1. 如果配置CMS，由于CMS采用标记清理算法，会有内存碎片的问题，推荐配置一个查看内存碎片程度的JVM参数PrintFLSStatistics。
2. 如果配置ParallelOldGC，那么每次Old区满后，会触发FullGC，如果FullGC频率过高，也可以通过上面OldGC段落提及的排查方法；
3. 如果没有配置-XX:+DisableExplicitGC，即没有屏蔽System.gc()触发FullGC，那么可以通过排查GC日志中有System字样判断是否System.gc()触发；或者通过jstat -gccause pid 2s pid判定，LGCC表示最近一次GC原因，如果为"System.gc"，表示由System.gc()触发，GCC表示当前GC原因，如果当前没有GC，那么就是No GC。

## Minor GC,Full GC触发条件

### MinorGC触发条件

- Eden区满了,或者新创建的对象大小大于了Eden区所剩余的空间
- Full GC的时候会先触发Minor GC

### Full GC触发条件

- Minor GC后存活的对象晋升到老年代时由于悲观策略的原因，有两种情况会触发Full GC, 一种是之前每次晋升的对象的平均大小 > 老年代剩余空间；一种是Minor GC后存活的对象超过了老年代剩余空间。这两种情况都是因为老年代会为新生代对象的晋升提供担保，而每次晋升的对象的大小是无法预测的，所以只能基于统计，一个是基于历史平均水平，一个是基于下一次可能要晋升的最大水平。这两种情况都是属于promotion failure
- CMS失败，发生concurrent mode failure会引起Full GC，这种情况下会使用Serial Old收集器，是单线程的，对GC的影响很大。concurrent mode failure产生的原因是老年代剩余的空间不够，导致了和gc线程并发执行的用户线程创建的大对象(由PretenureSizeThreshold控制新生代直接晋升老年代的对象size阀值)不能进入到老年代，只要stop the world来暂停用户线程，执行GC清理。可以通过设置CMSInitiatingOccupancyFraction预留合适的CMS执行时剩余的空间
- 新生代直接晋升到老年代的大对象超过了老年代的剩余空间，引发Full GC
- **Perm永久代空间不足会触发Full GC，可以让CMS清理永久代的空间**。设置CMSClassUnloadingEnabled即可
- **System.gc()引起的Full GC**，可以设置DisableExplicitGC来禁止调用System.gc引发Full GC

## 降低GC的调优策略

### 年轻代和老年代的大小优化

- `-Xms`,`-Xmx`通常设置为相同的值,避免运行时哟啊不断扩展JVM内存,这个值决定了JVM堆所能使用的最大内存
- `-Xmn`决定了新生代空间的大小,新生代Eden,S0,S1三个区域的比例可以通过`-XX:SurvivorRatio`来控制(假如值为4表示Eden:S0:S1 = 4:1:1 )
- `-XX:MaxTenuringThreshold `控制对象在经过多少次monorGC之后进入老年代,此参数只有在Serial串行GC时有效
- `-XX:PermSize`,`-XX:MaxPermSize`用来控制方法区的大小,通常设置为相同的值

注意事项:

1. 避免新生代大小设置过小

   这样会造成: 1. minorGC次数频繁; 2.可能导致大对象直接进入老年代,当老年代内存不足时,会触发FullGC

2. 避免新生代大小设置过大

   这样会造成: 1.老年代变小,可能导致FullGC频繁执行; 2.minorGC执行回收的时间大幅度增加

3. 避免Survivor区域过大或过小

   `-XX:SurvivorRatio`参数的值过大,就意味着Eden区变大,minorGC次数会降低,但两块Survivor区会变小,如果超过Survivor区内存大小的对象在minorGC后仍没被回收,则会直接进入老年代

   `-XX:SurvivorRatio`参数值设置过小，就意味着Eden区域变小，minor GC触发次数会增加,Survivor区会变大,意味着可以存储等多在minorGC后仍存活的对象,避免其进入老年代

4. 合理设置对象在新生代存活的周期

   新生代存活周期的值决定了新生代对象在经过多少次Minor GC后进入老年代。因此这个值要根据自己的应用来调优，Jvm参数上这个值对应的为-XX:MaxTenuringThreshold，默认值为15次。

### 减少GC开销的措施

1. 不要显示调用System.gc(); 此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会增加主GC的频率,也即增加了间歇性停顿的次数,大大的影响系统性能
2. 尽量减少临时对象的使用; 临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二触发条件出现的时间,减少了主GC的机会
3. 对象不用时最好显示设置为Null;一般而言,为null的对象都会被作为垃圾处理,所以将不用的对象显示的设置为null,有利于GC收集器判定垃圾,从而提高了GC的效率
4. 尽量使用StringBuffer,而不用String来累加字符串; 由于String是固定长的字符串对象,累加String对象时,并非在一个Strig对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象; 
5. 能用基本类型如int,long,就不用Integer,Long对象; 基本类型变量占用的内存资源相对于对象占用的少得多,如果没有必要,最好使用基本变量
6. 尽量少用静态对象变量; 静态变量属于全局变量,不会被GC会回收,他们会一直占用内存;
7. 分散对象创建或删除的时间; 集中在端时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率; 集中删除对象道理也一样;



# 参考文档

[深入详细讲解JVM原理](https://blog.csdn.net/know9163/article/details/80574488)

https://www.cnblogs.com/yuechuan/p/8984262.html

http://blog.itpub.net/29609890/viewspace-2219916/