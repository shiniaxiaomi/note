[TOC]

# 线性结构

## 线性表

线性表是一种线性结构,它是由零个或者多个数据元素构成的有限序列; 线性表的特征是在一个序列中,除了头尾元素,每个元素都有且只有一个直接前驱,有且只有一个直接后继

### 定义List接口

```java
public interface MyList {
    public void add(int value);
    public int remove(int index) throws Exception;
    public void update(int index,int value) throws Exception;
    public int get(int index) throws Exception;
    public int size();
}
```

### 数组实现

使用数组简单的实现ArrayList

```java
public class MyArrayList implements MyList {
    private int size=10;//定义数组的初始大小
    private int index=0;//数组索引
    private int[] arr=new int[size];//数组
    @Override
    public void add(int value) {
        if(index>=size){//如果超过数组长度,则扩容
            int[] newArr=new int[size*=2];
            System.arraycopy(arr,0,newArr,0,10);
            arr=newArr;
        }
        arr[index++]=value;
    }
    @Override
    public int remove(int index) throws Exception {
        if(index>this.index-1) throw new Exception("数组越界");//防止数组越界
        int buff=arr[index];
        for(int i=index;i<this.index-1;i++){
            arr[i]=arr[i+1];
        }
        this.index--;
        return buff;
    }
    @Override
    public void update(int index, int value) throws Exception {
        if(index>this.index-1) throw new Exception("数组越界");
        arr[index]=value;
    }
    @Override
    public int get(int index) throws Exception {
        if(index>this.index-1) throw new Exception("数组越界");
        return arr[index];
    }
    @Override
    public int size() {
        return this.index;
    }
    @Override
    public String toString() {
        return Arrays.toString(this.arr);
    }

    public static void main(String[] args) throws Exception {
        MyArrayList myArrayList = new MyArrayList();
        //增
        for(int i=0;i<8;i++){
            myArrayList.add(i);
        }
        System.out.println("增:"+myArrayList);
        //删
        int obj=myArrayList.remove(2);
        System.out.println("删:"+myArrayList);
        //改
        myArrayList.update(4,100);
        System.out.println("改:"+myArrayList);
        //查找
        int i = myArrayList.get(6);
        System.out.println(i);
        //大小
        System.out.println(myArrayList.size());
    }
}
```

### 链表实现

使用链表简单的实现LinkList

```java
public class MyLinkList implements MyList {
    //定义一个节点类
    private class Node{
        Node before;//上一个节点
        int value;//数据
        Node next;//下一个节点
        public Node(int value) {
            this.value = value;
        }
    }

    private Node head=null;//头节点
    private Node indexNode=null;//当前节点
    private int size=0;

    @Override
    public void add(int value) {
        if(head==null){
            Node node=new Node(value);
            head=node;//将head指向node节点
            indexNode=node;//将indexNode指向node节点
        }else{
            Node node=new Node(value);
            indexNode.next=node;//将indexNode的下一个节点指向node
            node.before=indexNode;//将node的上一个节点指向indexNode
            indexNode=node;//将当前节点修改成node
        }
        size++;
    }
    @Override
    public int remove(int index) throws Exception {
        Node node = getNode(index);
        node.before.next=node.next;//要删除节点的上一个节点的下一个指针指向删除节点的下一个node
        size--;
        return node.value;
    }
    @Override
    public void update(int index, int value) throws Exception {
        Node node = getNode(index);
        node.value=value;
    }
    @Override
    public int get(int index) throws Exception {
        Node node=getNode(index);
        return node.value;
    }
    @Override
    public int size() {
        return this.size;
    }
    @Override
    public String toString() {
        if(head==null) return null;
        StringBuilder sb=new StringBuilder();
        Node node=head;
        while (node!=null){
            sb.append(node.value+" ");
            node=node.next;
        }
        return sb.toString();
    }
    //根据索引获取node
    public Node getNode(int index) throws Exception {
        if(index>size-1) throw new Exception("越界");

        Node node=head;
        while(index>0){
            node=node.next;
            index--;
        }
        return node;
    }

    public static void main(String[] args) throws Exception {
        MyLinkList myLinkList = new MyLinkList();
        //增
        for(int i=0;i<10;i++){
            myLinkList.add(i);
        }
        System.out.println(myLinkList);
        //删
        myLinkList.remove(4);
        System.out.println(myLinkList);
        //改
        myLinkList.update(2,100);
        System.out.println(myLinkList);
        //查
        myLinkList.get(6);
        System.out.println(myLinkList);
        //大小
        System.out.println(myLinkList.size());
    }
}
```

## 堆栈

### 定义堆栈接口

```java
public interface MyStack {
    public void push(int value) throws Exception;
    public int pop() throws Exception;
    public int peek() throws Exception;//获取但不删除元素
    public boolean empty();
}
```

### 数组实现

```java
public class MyArrayStack implements MyStack {
    private int size=0;
    private int[] arr=null;
    private int index=0;//当前栈顶的指针

    //创建指定大小的堆栈
    public MyArrayStack(int size) {
        this.size = size;
        this.arr=new int[size];
    }

    @Override
    public void push(int value) throws Exception {
        if(index>size-1) throw new Exception("越界");
        arr[index++]=value;
    }
    @Override
    public int pop() throws Exception {
        if(index<0) throw new Exception("越界");
        return arr[--index];
    }
    @Override
    public boolean empty() {
        return index==0;
    }
    //获取但不删除元素
    @Override
    public int peek() throws Exception {
        if(index<0) throw new Exception("越界");
        return arr[index];
    }
    @Override
    public String toString() {
        StringBuilder sb=new StringBuilder();
        for(int i=0;i<index;i++){
            sb.append(arr[i]+" ");
        }
        return sb.toString();
    }

    public static void main(String[] args) throws Exception {
        MyArrayStack stack=new MyArrayStack(14);
        //push
        for(int i=0;i<10;i++){
            stack.push(i);
        }
        System.out.println(stack);
        //pop
        while(!stack.empty()){
            System.out.println(stack.pop());
        }
    }
}
```

### 链表实现

```java
public class MyLinkStack implements MyStack {
    private Node head=null;//记录一下头节点,方便toString()
    private int size=0;
    private Node indexNode=null;//当前栈顶的指针

    private class Node{
        Node before;
        int value;
        Node next;
        public Node(int value) {
            this.value = value;
        }
    }

    @Override
    public void push(int value) throws Exception {
        if(indexNode==null){
            indexNode=new Node(value);
            head=indexNode;
        }else{
            Node node=new Node(value);
            indexNode.next=node;
            node.before=indexNode;
            indexNode=node;
        }
        size++;
    }
    @Override
    public int pop() throws Exception {
        if(size<0) throw new Exception("越界");
        //如果是头节点
        if(size==1) {
            int value=indexNode.value;
            indexNode=null;//删除节点
            head=null;//头节点置空
            size--;
            return value;
        }

        int value=indexNode.value;
        indexNode.before.next=null;//删除当前节点
        indexNode=indexNode.before;
        size--;
        return value;
    }
    //获取但不删除元素
    @Override
    public int peek() throws Exception {
        if(size<0) throw new Exception("越界");
        return indexNode.value;
    }
    @Override
    public boolean empty() {
        return size==0;
    }
    @Override
    public String toString() {
        if(head==null) return null;
        StringBuilder sb=new StringBuilder();
        Node node=head;
        while(node!=null){
            sb.append(node.value+" ");
            node=node.next;
        }
        return sb.toString();
    }

    public static void main(String[] args) throws Exception {
        MyLinkStack stack=new MyLinkStack();
        //push
        for(int i=0;i<10;i++){
            stack.push(i);
        }
        System.out.println(stack);
        //pop
        while(!stack.empty()){
            System.out.println(stack.pop());
        }
    }
}
```

### JDK中的Stack使用Demo

```java
public class JDKStackDemo {
    public static void main(String[] args) {
        Stack<Object> stack = new Stack<>();
        for(int i=0;i<10;i++){
            stack.push(i);//添加元素
        }
        System.out.println(stack);
        while(!stack.empty()){
            System.out.println(stack.pop());//弹出元素
        }
        Object peek = stack.peek();//只获取但不删除最顶端的元素
        System.out.println(peek);
    }
}
```



## 队列

具有先进先出的特点,所有的新元素都插入到队列的末尾,移出元素都在队列的头部

### 定义Queue接口

```java
public interface MyQueue {
    //正常队列操作
    public void add();
    public void poll();
    public void peek();
    public boolean empty();
}
```

### 定义双端队列(Deque)接口

```java
// 该接口继承自MyQueue接口,并提供了头部和尾部的操作接口
public interface MyDeque extends MyQueue {
    //尾部的添加和获取操作
    public void addLast();
    public void getLast();
    //头部的添加和获取操作
    public void addFirst();
    public void getFirst();
}
```

### 双端队列(Deque)实现

继承自Queue,具有先进先出的特点,支持在头部和尾部添加和删除元素

> 相当于循环队列

#### 数组实现

```java
//该实现为简单起见,会浪费一个数组空间
public class MyArrayDeque implements MyDeque {
    private int size;//记录队列中的元素个数
    private int[] arr;
    private int firstIndex=-1;
    private int lastIndex=0;

    //生成指定大小的双端循环队列
    public MyArrayDeque(int length){
        this.arr=new int[length+1];
    }

    //在末端入队
    @Override
    public void add(int value) throws Exception {
        if(lastIndex==arr.length) lastIndex=0;//指向最后一个元素时,则让其指向0
        if(lastIndex==firstIndex) throw new Exception("队列已满");//如果头指针和尾指针相等,则不允许再放元素(其实中间还空着一个位置,因为lastIndex永远都指向下一个要放入的节点)
        arr[lastIndex++]=value;
        size++;
    }
    //在头部出队操作
    @Override
    public int poll() throws Exception {
        if(lastIndex==-1) lastIndex=arr.length-1;
        if(Math.abs(lastIndex-firstIndex)==1) throw new Exception("队列已空");//如果相差一个元素,则不允许再弹出元素
        size--;
        return arr[--lastIndex];
    }
    @Override
    public int peek() {
        return arr[lastIndex-1];
    }
    @Override
    public boolean empty() {
        return size==0;
    }
    //在末端入队
    @Override
    public void addLast(int value) throws Exception {
        this.add(value);
    }
    @Override
    public int getLast() throws Exception {
        return this.poll();
    }
    //在头部入队
    @Override
    public void addFirst(int value) throws Exception {
        if(firstIndex<=-1){
            firstIndex=this.arr.length-1;//如果到顶,则回到尾部
        }
        if(lastIndex==firstIndex) throw new Exception("队列已满");
        arr[firstIndex--]=value;
    }
    @Override
    public int getFirst() {
        if(firstIndex==this.arr.length-1){
            firstIndex=-1;//因为这里的firstIndex是先++,再取值,所以赋值为-1
        }
        return arr[++firstIndex];
    }
    @Override
    public String toString() {
        return Arrays.toString(arr);
    }
    //测试
    public static void main(String[] args) throws Exception {
        MyArrayDeque myArrayDeque = new MyArrayDeque(10);
        for(int i=0;i<6;i++){
            myArrayDeque.add(i);
        }
        System.out.println(myArrayDeque);
        System.out.println(myArrayDeque.peek());
        while (!myArrayDeque.empty()){
            int poll = myArrayDeque.poll();
            System.out.println(poll);
        }

        for(int i=0;i<10;i++){
            myArrayDeque.addLast(i);
        }
        System.out.println(myArrayDeque);

        for(int i=0;i<8;i++){
            int first = myArrayDeque.getFirst();
            System.out.println(first);
        }
        for(int i=0;i<2;i++){
            int last = myArrayDeque.getLast();
            System.out.println(last);
        }
    }
}

```

#### 链表实现

```java
public class MyLinkDeque implements MyDeque{
    private Node head;//记录头节点
    private Node last;//记录尾节点
    private int size=0;//记录当前节点个数

    private class Node{
        Node before;//指向上一个节点
        int value;//保存的数据
        Node next;//指向下一个节点
        public Node(int value){
            this.value=value;
        }
    }

    //默认添加在尾部
    @Override
    public void add(int value) {
        if(last==null){
            Node node = new Node(value);
            last=node;
            if(head==null){
                head=node;
            }
        }else{
            Node node=new Node(value);
            last.next=node;
            node.before=last;
            last=node;
        }
        size++;
    }

    //默认从头部弹出数据
    @Override
    public int poll() throws Exception {
        if(size==0) throw new Exception("empty");
        Node node=last;//保存要删除的节点
        last.before.next=null;//删除该节点
        last=last.before;
        size--;
        return node.value;
    }
    @Override
    public int peek() {
        return last.value;
    }
    @Override
    public boolean empty() {
        return size==0;
    }
    //将数据添加到尾部
    @Override
    public void addLast(int value) {
        this.add(value);
    }
    @Override
    public int getLast() throws Exception {
        return this.poll();
    }
    //将数据添加到头部
    @Override
    public void addFirst(int value) {
        if(head==null){
            Node node=new Node(value);
            head=node;
            if(last==null){
                last=node;
            }
        }else{
            Node node=new Node(value);
            head.before=node;
            node.next=head;
            head=node;
        }
        size++;
    }
    //从头部获取数据
    @Override
    public int getFirst() throws Exception {
        if(size==0) throw new Exception("empty");
        Node node=head;//保存要删除的节点
        head.next.before=null;//删除节点
        head=head.next;
        size--;
        return node.value;
    }
    @Override
    public String toString() {
        if(head==null) return null;
        StringBuilder sb=new StringBuilder();
        Node node=head;
        while(node!=null){
            sb.append(node.value+" ");
            node=node.next;
        }
        return sb.toString();
    }
    public static void main(String[] args) throws Exception {
        MyLinkDeque myLinkDeque = new MyLinkDeque();
        //添加
        for(int i=0;i<10;i++){
            myLinkDeque.add(i);
        }
        System.out.println(myLinkDeque);
        //弹出
        for(int i=0;i<3;i++){
            int poll = myLinkDeque.poll();
            System.out.println(poll);
        }
        System.out.println(myLinkDeque);

        //添加头部数据
        for(int i=0;i<5;i++){
            myLinkDeque.addFirst(i);
        }
        //添加尾部数据
        for(int i=50;i<55;i++){
            myLinkDeque.addLast(i);
        }
        System.out.println(myLinkDeque);

        //获取头部数据
        for(int i=0;i<3;i++){
            int first = myLinkDeque.getFirst();
            System.out.println(first);
        }
        //获取尾部数据
        for(int i=0;i<3;i++){
            int last = myLinkDeque.getLast();
            System.out.println(last);
        }
        System.out.println(myLinkDeque);
    }
}
```

### 优先队列(PriorityQueue)实现

元素可以按照任意顺序插入,却总是按照排序的顺序检索,也就是说,无论何时调用remove方法,总会获得当前优先队列中的最小元素

优先队列使用了一个高效的数据结构-堆(最大堆和最小堆)

优先队列会实现MyQueue接口,只提供一些普通队列的操作

优先队列的典型应用是任务调度; 每个任务都有优先级,任务以随机顺序添加到优先队列中,每当启动一个新的任务时,都将优先级最高或最低(这个可以自己指定)的任务从队列中删除

该实现可以参考本文`堆`数据结构的实现(最大堆和最小堆)

### JDK中的队列使用Demo

#### 双端队列

```java
public class JDKQueueDemo {
    public static void main(String[] args) {
        //双端队列
        ArrayDeque<Object> arrayDeque = new ArrayDeque<>();
        arrayDeque.addLast(1);//指定加载末尾
        arrayDeque.addLast(2);
        arrayDeque.addLast(3);
        arrayDeque.add(4);//add默认加载尾部
        Object poll1 = arrayDeque.poll();//poll默认弹出头部
        System.out.println(poll1);
        Object last = arrayDeque.getLast();
        System.out.println(last);
        Object first = arrayDeque.getFirst();
        System.out.println(first);
    }
}
```

> 结果: 
>
> last: 3
>
> first: 1

#### 优先队列

```java
public class JDKQueueDemo {
    public static void main(String[] args) {
        //定义比较的规则(按照降序,即最大堆)
        Comparator<Integer> comparator=new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2-o1;
            }
        };
        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>(comparator);//创建优先队列
        priorityQueue.add(1);
        priorityQueue.add(5);
        priorityQueue.add(2);
        priorityQueue.add(4);
        priorityQueue.add(3);
        while (!priorityQueue.isEmpty()){
            Object poll = priorityQueue.poll();
            System.out.println(poll);
        }
    }
}
```

> 乱序插入,获取是从大到小获取(最大堆)
>
> 结果:  5 4 3 2 1

# 树

树是n个节点的有限集合,当n=0时,成为空树,在任意一颗非空树中,有这样的定义:

- 有且仅有一个特定的称为根的节点(Root)
- 当n>1时,其余节点可分为m个互不相交的有限集合(T1,T2...Tn),其中每个集合本身又是一颗树,称之为子树

![这里写图片描述](.img/.数据结构/20180727103432889.png)

树的定义:

树的节点包含一个数据元素及若干个指向其子树的分支,节点拥有的子树数量成为节点的度

节点的分类:

- 叶节点: 度为0的节点
- 分支节点: 度不为0的节点

![这里写图片描述](.img/.数据结构/20180727104650484-1569471692767)

节点间的关系:

父节点=>孩子节点=>兄弟节点

![这里写图片描述](.img/.数据结构/20180727104953224.png)

节点的层次:

层次(level)从根开始定义,树中节点的最大层次成为树的深度(depth)或高度

![这里写图片描述](.img/.数据结构/20180727105113115.png)

## 二叉树

### 定义

二叉树(binary tree) 是n个节点的有限集合,该集合有一个根节点和两颗互不相交的左子树和右子树

特点:

- 每个节点最多有两颗子树,所以二叉树中不存在度大于2的节点
- 左子树和右子树是有顺序的,次序布恩那个任意颠倒
- 即使树中某节点只有一颗子树,也要区分他是左子树还是右子树

### 二叉树的五种形态

![这里写图片描述](.img/.数据结构/20180727111203962.png)

### 特殊二叉树

#### 斜树

所有节点只有左子树的二叉树叫做左斜树

所有节点只有右子树的二叉树叫做右斜树

#### 满二叉树

所有分支节点都存在左子树和右子树,并且所有叶子都在同一层上的二叉树

![1569472484633](.img/.数据结构/1569472484633.png)

1. 叶子只能出现在最下一层
2. 非叶子节点的度一定是2
3. 在同样深度的二叉树中,满二叉树的节点个数最多,叶子数最多

#### 完全二叉树

对一颗有n个节点的二叉树按层序编号,如果编号为i的节点与同样深度的满二叉树中编号为i的节点在二叉树中的位置完全相同,则是完全二叉树

![](.img/.数据结构/20180727112538865.png)

满二叉树一定是完全二叉树,完全二叉树不一定是满二叉树

特点:

1. 叶子节点只能出现在最下两层
2. 最下曾的叶子一定集中在左部连续位置
3. 倒数第二层,若有叶子节点,一定都是右部连续位置
4. 如果节点度为1,则该节点只有左孩子,即不存在只有右子树的情况
5. 同样节点数的二叉树,完全二叉树的深度最小

## 二叉树的性质

- 在二叉树的第i层,至多右2的i-1次方个节点

  ![](.img/.数据结构/2018072711290314.png)

  第一层: 2的0次方,为1个

  第二层: 2的1次方,为2个

  第三层: 2的2次方,为4个

  第i层: 2的i-1次方

- 深度为k的二叉树最多有2的k次方-1个节点(计算总结点个数)

  如果有一层: 至多1=2的0次方-1个节点

  如果有二层: 至多1+2=2的2次方-1个节点

  如果有三层: 至多1+2+3=2的3次方-1个节点

  如果有i层: 至多1+2+4+...+2的i-1次方=2的i次方-1个节点

- 具有n个节点的完全二叉树的深度为log2N+1

- 对于完二叉树的任意节点i

  对于一颗有n个节点的完全二叉树,其节点按照层序编号进行以此排序,如下图所示

  ![1569477140020](.img/.数据结构/1569477140020.png)

  1. 如果i=1,则节点i时二叉树的根,无父节点;如果i>1,则其父节点是i/2(不管该节点是左孩子还是右孩子,都是i/2)
  2. 如果2*i>n,则节点i无左孩子,即该节点为叶子节点
  3. 如果2*i+1>n,则节点i无右孩子

## 完全二叉树的遍历

### 数组实现

![这里写图片描述](.img/.数据结构/20180727120134318)

#### 深度优先遍历(前中后序遍历)

- 前序遍历

  先访问根节点,再遍历左子树,再遍历右子树

- 中序遍历

  先遍历左子树,再访问根节点,再遍历右子树

- 后序遍历

  先遍历左子树,再遍历右子树,再访问根节点

代码实现

```java
//完全二叉树的数组实现(前中后序遍历)
public class FullArrayBinaryTree {
    private int[] arr=null;//保存数据
    public FullArrayBinaryTree(int[] arr) {
        this.arr = arr;
    }
    //根据当前节点的index获取其左孩子的index
    public int getLeftChildren(int index) throws Exception {
        if(2*index+1>arr.length-1) return -1;//无左孩子
        return 2*index+1;
    }
    //根据当前节点的index获取其右孩子的index
    public int getRightChildren(int index) throws Exception {
        if(2*index+2>arr.length-1)  return -1;//无右孩子
        return 2*index+2;
    }
    
    //前序遍历
    public void preOrder(int index) throws Exception {
        System.out.print(arr[index]+" ");//访问当前节点

        int leftChildrenIndex = getLeftChildren(index);
        if(leftChildrenIndex!=-1){
            preOrder(leftChildrenIndex);//访问左孩子
        }

        int rightChildrenIndex = getRightChildren(index);
        if (rightChildrenIndex!=-1){
            preOrder(rightChildrenIndex);//访问右孩子
        }
    }
    //中序遍历
    public void inOrder(int index) throws Exception {
        int leftChildrenIndex = getLeftChildren(index);
        if(leftChildrenIndex!=-1){
            inOrder(leftChildrenIndex);//访问左孩子
        }

        System.out.print(arr[index]+" ");//访问当前节点

        int rightChildrenIndex = getRightChildren(index);
        if (rightChildrenIndex!=-1){
            inOrder(rightChildrenIndex);//访问右孩子
        }
    }
    //后序遍历
    public void postOrder(int index) throws Exception {
        int leftChildrenIndex = getLeftChildren(index);
        if(leftChildrenIndex!=-1){
            postOrder(leftChildrenIndex);//访问左孩子
        }

        int rightChildrenIndex = getRightChildren(index);
        if (rightChildrenIndex!=-1){
            postOrder(rightChildrenIndex);//访问右孩子
        }

        System.out.print(arr[index]+" ");//访问当前节点
    }
    //测试
    public static void main(String[] args) throws Exception {
        int[] arr=new int[10];
        for(int i=0;i<10;i++){
            arr[i]=i;
        }
        FullArrayBinaryTree fullArrayBinaryTree = new FullArrayBinaryTree(arr);
        fullArrayBinaryTree.preOrder(0);//前序遍历
        fullArrayBinaryTree.inOrder(0);//中序遍历
        fullArrayBinaryTree.postOrder(0);//后序遍历
    }
}
```

#### 广度优先遍历

数组实现的广度优先遍历就是传入数组的顺序遍历

> 代码略

### 链表实现

![这里写图片描述](.img/.数据结构/20180727120527706.png)

#### 深度优先遍历(前中后序遍历)

```java
public class FullLinkBinaryTree {
    Node head;//头节点  
    private class Node{
        Node leftChildren;
        int value;
        Node rightChildren;
        public Node(int value){
            this.value=value;
        }
    }
    //通过数组生成完全二叉树
    public FullLinkBinaryTree(int[] arr){
        ArrayDeque<Node> deque = new ArrayDeque<>();
        head=new Node(arr[0]);
        deque.add(head);
        int i=1;
        while(!deque.isEmpty()){
            Node poll = deque.poll();

            if(i+1>arr.length){
                deque.clear();
                break;
            }
            Node leftChildren=new Node(arr[i++]);
            poll.leftChildren=leftChildren;
            deque.add(leftChildren);

            if(i+1>arr.length){
                deque.clear();
                break;
            }
            Node rightChildren=new Node(arr[i++]);
            poll.rightChildren=rightChildren;
            deque.add((rightChildren));
        }
    }
    //先序遍历
    public void preOrder(Node node){
        if(node==null) return;
        System.out.print(node.value+" ");//访问当前节点
        preOrder(node.leftChildren);//访问左节点
        preOrder(node.rightChildren);//访问右节点
    }
    //中序遍历
    public void inOrder(Node node){
        if(node==null) return;
        inOrder(node.leftChildren);//访问左节点
        System.out.print(node.value+" ");//访问当前节点
        inOrder(node.rightChildren);//访问右节点
    }
    //后序遍历
    public void postOrder(Node node){
        if(node==null) return;
        postOrder(node.leftChildren);//访问左节点
        postOrder(node.rightChildren);//访问右节点
        System.out.print(node.value+" ");//访问当前节点
    }
    //测试
    public static void main(String[] args) {
        int[] arr=new int[10];
        for(int i=0;i<10;i++){
            arr[i]=i;
        }
        FullLinkBinaryTree fullLinkBinaryTree = new FullLinkBinaryTree(arr);
        fullLinkBinaryTree.preOrder(fullLinkBinaryTree.head);//前序遍历
        System.out.println();
        fullLinkBinaryTree.inOrder(fullLinkBinaryTree.head);//中序遍历
        System.out.println();
        fullLinkBinaryTree.postOrder(fullLinkBinaryTree.head);//后序遍历
    }
}
```

#### 广度优先遍历

```java
public class FullLinkBinaryTree {
    Node head;//头节点
    private class Node{
        Node leftChildren;
        int value;
        Node rightChildren;
        public Node(int value){
            this.value=value;
        }
    }
    public FullLinkBinaryTree(int[] arr){
        ArrayDeque<Node> deque = new ArrayDeque<>();
        head=new Node(arr[0]);
        deque.add(head);
        int i=1;
        while(!deque.isEmpty()){
            Node poll = deque.poll();

            if(i+1>arr.length){
                deque.clear();
                break;
            }
            Node leftChildren=new Node(arr[i++]);
            poll.leftChildren=leftChildren;
            deque.add(leftChildren);

            if(i+1>arr.length){
                deque.clear();
                break;
            }
            Node rightChildren=new Node(arr[i++]);
            poll.rightChildren=rightChildren;
            deque.add((rightChildren));
        }
    }
    //广度优先遍历
    public void BFS(Node node){
        if(node==null) {
            System.out.println("null");
            return;
        }

        ArrayDeque<Node> deque = new ArrayDeque<>();
        deque.add(node);
        //如果deque不为空
        while(!deque.isEmpty()){
            Node poll = deque.poll();
            System.out.print(poll.value+" ");

            if(poll.leftChildren!=null) {
                deque.add(poll.leftChildren);//压入左节点
            }

            if(poll.rightChildren!=null){
                deque.add(poll.rightChildren);//压入右节点
            }
        }
    }
    //测试
    public static void main(String[] args) {
        int[] arr=new int[10];
        for(int i=0;i<10;i++){
            arr[i]=i;
        }
        FullLinkBinaryTree fullLinkBinaryTree = new FullLinkBinaryTree(arr);
        fullLinkBinaryTree.BFS(fullLinkBinaryTree.head);//广度优先遍历
    }
}
```

## 二叉搜索树

由于二叉搜索树的定义和特性,他可以高效解决以下问题:

- 查找问题: 二分查找
- 高级结构: 字典结构实现
- 数据变动: 节点的插入,删除
- 遍历问题: 前序,中序,后序和层序遍历
- 数值运算: ceil,floor,找到第n大的元素,找到指定元素在排序好的数组的位置等等

值得一提的是,除了遍历算法,上述各种问题的算法的时间复杂度都是O(log2N)



二叉树搜索树的定义和性质

- 若任意节点的左子树不空,则左子树上所有节点的值均小于该节点的值
- 若任意节点的右子树不空,则右子树上所有节点的值均大于该节点的值
- 任意节点的左,右子树也分别二叉搜索树
- 没有键值相等的节点

> 注意: 二叉搜索树不一定是一个完全二叉树,因此,二叉搜索树不能用数组来存储

### 二叉搜索树的接口定义



### 二叉搜索树数组实现

### 二叉搜索树链表实现

### JDK中二叉搜索树的使用demo

```java
public class JDKBinarySearchTreeDemo {
    public static void main(String[] args) {
        TreeSet<Integer> treeSet = new TreeSet<>();//其实是一个最大最小堆
        treeSet.add(5);
        treeSet.add(2);
        treeSet.add(4);
        Integer pollFirst = treeSet.pollFirst();
        System.out.println(pollFirst);
        Integer pollLast = treeSet.pollLast();
        System.out.println(pollLast);
    }
}
```

## 平衡二叉树(AVL树)

略

## 红黑树

略

## 哈夫曼树

略

## 多叉树

略

# 堆

数组实现和链表实现

## 最大堆

## 最小堆

# 图

## 图的定义

## 图的遍历

### 深度优先遍历

### 广度优先遍历

## 单源最短路径问题

### 有向无权图

### 有向有权图

# 散列表

HashMap

# 算法时间复杂度计算

# 参考文档

[数据结构图文解析C++实现](https://blog.csdn.net/LiuJiuXiaoShiTou/article/details/77095156)

[数据结构知识点](https://blog.csdn.net/jiaoyangwm/article/details/80808235)

[数据结构java实现](https://blog.csdn.net/npz1999/article/details/89460531)