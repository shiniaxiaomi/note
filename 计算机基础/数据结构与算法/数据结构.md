[TOC]

# 线性结构

## 线性表

线性表是一种线性结构,它是由零个或者多个数据元素构成的有限序列; 线性表的特征是在一个序列中,除了头尾元素,每个元素都有且只有一个直接前驱,有且只有一个直接后继

### 定义List接口

```java
public interface MyList {
    public void add(int value);
    public int remove(int index) throws Exception;
    public void update(int index,int value) throws Exception;
    public int get(int index) throws Exception;
    public int size();
}
```

### 数组实现

使用数组简单的实现ArrayList

```java
public class MyArrayList implements MyList {
    private int size=10;//定义数组的初始大小
    private int index=0;//数组索引
    private int[] arr=new int[size];//数组
    @Override
    public void add(int value) {
        if(index>=size){//如果超过数组长度,则扩容
            int[] newArr=new int[size*=2];
            System.arraycopy(arr,0,newArr,0,10);
            arr=newArr;
        }
        arr[index++]=value;
    }
    @Override
    public int remove(int index) throws Exception {
        if(index>this.index-1) throw new Exception("数组越界");//防止数组越界
        int buff=arr[index];
        for(int i=index;i<this.index-1;i++){
            arr[i]=arr[i+1];
        }
        this.index--;
        return buff;
    }
    @Override
    public void update(int index, int value) throws Exception {
        if(index>this.index-1) throw new Exception("数组越界");
        arr[index]=value;
    }
    @Override
    public int get(int index) throws Exception {
        if(index>this.index-1) throw new Exception("数组越界");
        return arr[index];
    }
    @Override
    public int size() {
        return this.index;
    }
    @Override
    public String toString() {
        return Arrays.toString(this.arr);
    }

    public static void main(String[] args) throws Exception {
        MyArrayList myArrayList = new MyArrayList();
        //增
        for(int i=0;i<8;i++){
            myArrayList.add(i);
        }
        System.out.println("增:"+myArrayList);
        //删
        int obj=myArrayList.remove(2);
        System.out.println("删:"+myArrayList);
        //改
        myArrayList.update(4,100);
        System.out.println("改:"+myArrayList);
        //查找
        int i = myArrayList.get(6);
        System.out.println(i);
        //大小
        System.out.println(myArrayList.size());
    }
}
```

### 链表实现

使用链表简单的实现LinkList

```java
public class MyLinkList implements MyList {
    //定义一个节点类
    private class Node{
        Node before;//上一个节点
        int value;//数据
        Node next;//下一个节点
        public Node(int value) {
            this.value = value;
        }
    }

    private Node head=null;//头节点
    private Node indexNode=null;//当前节点
    private int size=0;

    @Override
    public void add(int value) {
        if(head==null){
            Node node=new Node(value);
            head=node;//将head指向node节点
            indexNode=node;//将indexNode指向node节点
        }else{
            Node node=new Node(value);
            indexNode.next=node;//将indexNode的下一个节点指向node
            node.before=indexNode;//将node的上一个节点指向indexNode
            indexNode=node;//将当前节点修改成node
        }
        size++;
    }
    @Override
    public int remove(int index) throws Exception {
        Node node = getNode(index);
        node.before.next=node.next;//要删除节点的上一个节点的下一个指针指向删除节点的下一个node
        size--;
        return node.value;
    }
    @Override
    public void update(int index, int value) throws Exception {
        Node node = getNode(index);
        node.value=value;
    }
    @Override
    public int get(int index) throws Exception {
        Node node=getNode(index);
        return node.value;
    }
    @Override
    public int size() {
        return this.size;
    }
    @Override
    public String toString() {
        if(head==null) return null;
        StringBuilder sb=new StringBuilder();
        Node node=head;
        while (node!=null){
            sb.append(node.value+" ");
            node=node.next;
        }
        return sb.toString();
    }
    //根据索引获取node
    public Node getNode(int index) throws Exception {
        if(index>size-1) throw new Exception("越界");

        Node node=head;
        while(index>0){
            node=node.next;
            index--;
        }
        return node;
    }

    public static void main(String[] args) throws Exception {
        MyLinkList myLinkList = new MyLinkList();
        //增
        for(int i=0;i<10;i++){
            myLinkList.add(i);
        }
        System.out.println(myLinkList);
        //删
        myLinkList.remove(4);
        System.out.println(myLinkList);
        //改
        myLinkList.update(2,100);
        System.out.println(myLinkList);
        //查
        myLinkList.get(6);
        System.out.println(myLinkList);
        //大小
        System.out.println(myLinkList.size());
    }
}
```

## 堆栈

### 定义堆栈接口

```java
public interface MyStack {
    public void push(int value) throws Exception;
    public int pop() throws Exception;
    public int peek() throws Exception;//获取但不删除元素
    public boolean empty();
}
```

### 数组实现

```java
public class MyArrayStack implements MyStack {
    private int size=0;
    private int[] arr=null;
    private int index=0;//当前栈顶的指针

    //创建指定大小的堆栈
    public MyArrayStack(int size) {
        this.size = size;
        this.arr=new int[size];
    }

    @Override
    public void push(int value) throws Exception {
        if(index>size-1) throw new Exception("越界");
        arr[index++]=value;
    }
    @Override
    public int pop() throws Exception {
        if(index<0) throw new Exception("越界");
        return arr[--index];
    }
    @Override
    public boolean empty() {
        return index==0;
    }
    //获取但不删除元素
    @Override
    public int peek() throws Exception {
        if(index<0) throw new Exception("越界");
        return arr[index];
    }
    @Override
    public String toString() {
        StringBuilder sb=new StringBuilder();
        for(int i=0;i<index;i++){
            sb.append(arr[i]+" ");
        }
        return sb.toString();
    }

    public static void main(String[] args) throws Exception {
        MyArrayStack stack=new MyArrayStack(14);
        //push
        for(int i=0;i<10;i++){
            stack.push(i);
        }
        System.out.println(stack);
        //pop
        while(!stack.empty()){
            System.out.println(stack.pop());
        }
    }
}
```

### 链表实现

```java
public class MyLinkStack implements MyStack {
    private Node head=null;//记录一下头节点,方便toString()
    private int size=0;
    private Node indexNode=null;//当前栈顶的指针

    private class Node{
        Node before;
        int value;
        Node next;
        public Node(int value) {
            this.value = value;
        }
    }

    @Override
    public void push(int value) throws Exception {
        if(indexNode==null){
            indexNode=new Node(value);
            head=indexNode;
        }else{
            Node node=new Node(value);
            indexNode.next=node;
            node.before=indexNode;
            indexNode=node;
        }
        size++;
    }
    @Override
    public int pop() throws Exception {
        if(size<0) throw new Exception("越界");
        //如果是头节点
        if(size==1) {
            int value=indexNode.value;
            indexNode=null;//删除节点
            head=null;//头节点置空
            size--;
            return value;
        }

        int value=indexNode.value;
        indexNode.before.next=null;//删除当前节点
        indexNode=indexNode.before;
        size--;
        return value;
    }
    //获取但不删除元素
    @Override
    public int peek() throws Exception {
        if(size<0) throw new Exception("越界");
        return indexNode.value;
    }
    @Override
    public boolean empty() {
        return size==0;
    }
    @Override
    public String toString() {
        if(head==null) return null;
        StringBuilder sb=new StringBuilder();
        Node node=head;
        while(node!=null){
            sb.append(node.value+" ");
            node=node.next;
        }
        return sb.toString();
    }

    public static void main(String[] args) throws Exception {
        MyLinkStack stack=new MyLinkStack();
        //push
        for(int i=0;i<10;i++){
            stack.push(i);
        }
        System.out.println(stack);
        //pop
        while(!stack.empty()){
            System.out.println(stack.pop());
        }
    }
}
```

### JDK中的Stack使用Demo

```java
public class JDKStackDemo {
    public static void main(String[] args) {
        Stack<Object> stack = new Stack<>();
        for(int i=0;i<10;i++){
            stack.push(i);//添加元素
        }
        System.out.println(stack);
        while(!stack.empty()){
            System.out.println(stack.pop());//弹出元素
        }
        Object peek = stack.peek();//只获取但不删除最顶端的元素
        System.out.println(peek);
    }
}
```



## 队列

具有先进先出的特点,所有的新元素都插入到队列的末尾,移出元素都在队列的头部

### 定义Queue接口

```java
public interface MyQueue {
    //正常队列操作
    public void add();
    public void poll();
    public void peek();
    public boolean empty();
}
```

### 定义双端队列(Deque)接口

```java
// 该接口继承自MyQueue接口,并提供了头部和尾部的操作接口
public interface MyDeque extends MyQueue {
    //尾部的添加和获取操作
    public void addLast();
    public void getLast();
    //头部的添加和获取操作
    public void addFirst();
    public void getFirst();
}
```

### 双端队列(Deque)实现

继承自Queue,具有先进先出的特点,支持在头部和尾部添加和删除元素

> 相当于循环队列

#### 数组实现

```java
//该实现为简单起见,会浪费一个数组空间
public class MyArrayDeque implements MyDeque {
    private int size;//记录队列中的元素个数
    private int[] arr;
    private int firstIndex=-1;
    private int lastIndex=0;

    //生成指定大小的双端循环队列
    public MyArrayDeque(int length){
        this.arr=new int[length+1];
    }

    //在末端入队
    @Override
    public void add(int value) throws Exception {
        if(lastIndex==arr.length) lastIndex=0;//指向最后一个元素时,则让其指向0
        if(lastIndex==firstIndex) throw new Exception("队列已满");//如果头指针和尾指针相等,则不允许再放元素(其实中间还空着一个位置,因为lastIndex永远都指向下一个要放入的节点)
        arr[lastIndex++]=value;
        size++;
    }
    //在头部出队操作
    @Override
    public int poll() throws Exception {
        if(lastIndex==-1) lastIndex=arr.length-1;
        if(Math.abs(lastIndex-firstIndex)==1) throw new Exception("队列已空");//如果相差一个元素,则不允许再弹出元素
        size--;
        return arr[--lastIndex];
    }
    @Override
    public int peek() {
        return arr[lastIndex-1];
    }
    @Override
    public boolean empty() {
        return size==0;
    }
    //在末端入队
    @Override
    public void addLast(int value) throws Exception {
        this.add(value);
    }
    @Override
    public int getLast() throws Exception {
        return this.poll();
    }
    //在头部入队
    @Override
    public void addFirst(int value) throws Exception {
        if(firstIndex<=-1){
            firstIndex=this.arr.length-1;//如果到顶,则回到尾部
        }
        if(lastIndex==firstIndex) throw new Exception("队列已满");
        arr[firstIndex--]=value;
    }
    @Override
    public int getFirst() {
        if(firstIndex==this.arr.length-1){
            firstIndex=-1;//因为这里的firstIndex是先++,再取值,所以赋值为-1
        }
        return arr[++firstIndex];
    }
    @Override
    public String toString() {
        return Arrays.toString(arr);
    }
    //测试
    public static void main(String[] args) throws Exception {
        MyArrayDeque myArrayDeque = new MyArrayDeque(10);
        for(int i=0;i<6;i++){
            myArrayDeque.add(i);
        }
        System.out.println(myArrayDeque);
        System.out.println(myArrayDeque.peek());
        while (!myArrayDeque.empty()){
            int poll = myArrayDeque.poll();
            System.out.println(poll);
        }

        for(int i=0;i<10;i++){
            myArrayDeque.addLast(i);
        }
        System.out.println(myArrayDeque);

        for(int i=0;i<8;i++){
            int first = myArrayDeque.getFirst();
            System.out.println(first);
        }
        for(int i=0;i<2;i++){
            int last = myArrayDeque.getLast();
            System.out.println(last);
        }
    }
}

```

#### 链表实现

```java
public class MyLinkDeque implements MyDeque{
    private Node head;//记录头节点
    private Node last;//记录尾节点
    private int size=0;//记录当前节点个数

    private class Node{
        Node before;//指向上一个节点
        int value;//保存的数据
        Node next;//指向下一个节点
        public Node(int value){
            this.value=value;
        }
    }

    //默认添加在尾部
    @Override
    public void add(int value) {
        if(last==null){
            Node node = new Node(value);
            last=node;
            if(head==null){
                head=node;
            }
        }else{
            Node node=new Node(value);
            last.next=node;
            node.before=last;
            last=node;
        }
        size++;
    }

    //默认从头部弹出数据
    @Override
    public int poll() throws Exception {
        if(size==0) throw new Exception("empty");
        Node node=last;//保存要删除的节点
        last.before.next=null;//删除该节点
        last=last.before;
        size--;
        return node.value;
    }
    @Override
    public int peek() {
        return last.value;
    }
    @Override
    public boolean empty() {
        return size==0;
    }
    //将数据添加到尾部
    @Override
    public void addLast(int value) {
        this.add(value);
    }
    @Override
    public int getLast() throws Exception {
        return this.poll();
    }
    //将数据添加到头部
    @Override
    public void addFirst(int value) {
        if(head==null){
            Node node=new Node(value);
            head=node;
            if(last==null){
                last=node;
            }
        }else{
            Node node=new Node(value);
            head.before=node;
            node.next=head;
            head=node;
        }
        size++;
    }
    //从头部获取数据
    @Override
    public int getFirst() throws Exception {
        if(size==0) throw new Exception("empty");
        Node node=head;//保存要删除的节点
        head.next.before=null;//删除节点
        head=head.next;
        size--;
        return node.value;
    }
    @Override
    public String toString() {
        if(head==null) return null;
        StringBuilder sb=new StringBuilder();
        Node node=head;
        while(node!=null){
            sb.append(node.value+" ");
            node=node.next;
        }
        return sb.toString();
    }
    public static void main(String[] args) throws Exception {
        MyLinkDeque myLinkDeque = new MyLinkDeque();
        //添加
        for(int i=0;i<10;i++){
            myLinkDeque.add(i);
        }
        System.out.println(myLinkDeque);
        //弹出
        for(int i=0;i<3;i++){
            int poll = myLinkDeque.poll();
            System.out.println(poll);
        }
        System.out.println(myLinkDeque);

        //添加头部数据
        for(int i=0;i<5;i++){
            myLinkDeque.addFirst(i);
        }
        //添加尾部数据
        for(int i=50;i<55;i++){
            myLinkDeque.addLast(i);
        }
        System.out.println(myLinkDeque);

        //获取头部数据
        for(int i=0;i<3;i++){
            int first = myLinkDeque.getFirst();
            System.out.println(first);
        }
        //获取尾部数据
        for(int i=0;i<3;i++){
            int last = myLinkDeque.getLast();
            System.out.println(last);
        }
        System.out.println(myLinkDeque);
    }
}
```

### 优先队列(PriorityQueue)实现

元素可以按照任意顺序插入,却总是按照排序的顺序检索,也就是说,无论何时调用remove方法,总会获得当前优先队列中的最小元素

优先队列使用了一个高效的数据结构-堆(最大堆和最小堆)

优先队列会实现MyQueue接口,只提供一些普通队列的操作

优先队列的典型应用是任务调度; 每个任务都有优先级,任务以随机顺序添加到优先队列中,每当启动一个新的任务时,都将优先级最高或最低(这个可以自己指定)的任务从队列中删除

该实现可以参考本文`堆`数据结构的实现(最大堆和最小堆)

### JDK中的队列使用Demo

#### 双端队列

```java
public class JDKQueueDemo {
    public static void main(String[] args) {
        //双端队列
        ArrayDeque<Object> arrayDeque = new ArrayDeque<>();
        arrayDeque.addLast(1);//指定加载末尾
        arrayDeque.addLast(2);
        arrayDeque.addLast(3);
        arrayDeque.add(4);//add默认加载尾部
        Object poll1 = arrayDeque.poll();//poll默认弹出头部
        System.out.println(poll1);
        Object last = arrayDeque.getLast();
        System.out.println(last);
        Object first = arrayDeque.getFirst();
        System.out.println(first);
    }
}
```

> 结果: 
>
> last: 3
>
> first: 1

#### 优先队列

```java
public class JDKQueueDemo {
    public static void main(String[] args) {
        //定义比较的规则(按照降序,即最大堆)
        Comparator<Integer> comparator=new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2-o1;
            }
        };
        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>(comparator);//创建优先队列
        priorityQueue.add(1);
        priorityQueue.add(5);
        priorityQueue.add(2);
        priorityQueue.add(4);
        priorityQueue.add(3);
        while (!priorityQueue.isEmpty()){
            Object poll = priorityQueue.poll();
            System.out.println(poll);
        }
    }
}
```

> 乱序插入,获取是从大到小获取(最大堆)
>
> 结果:  5 4 3 2 1

# 树

树是n个节点的有限集合,当n=0时,成为空树,在任意一颗非空树中,有这样的定义:

- 有且仅有一个特定的称为根的节点(Root)
- 当n>1时,其余节点可分为m个互不相交的有限集合(T1,T2...Tn),其中每个集合本身又是一颗树,称之为子树

![这里写图片描述](D:\note\.img\20180727103432889.png)

树的定义:

树的节点包含一个数据元素及若干个指向其子树的分支,节点拥有的子树数量成为节点的度

节点的分类:

- 叶节点: 度为0的节点
- 分支节点: 度不为0的节点

![这里写图片描述](D:\note\.img\20180727104650484-1569471692767)

节点间的关系:

父节点=>孩子节点=>兄弟节点

![这里写图片描述](D:\note\.img\20180727104953224.png)

节点的层次:

层次(level)从根开始定义,树中节点的最大层次成为树的深度(depth)或高度

![这里写图片描述](D:\note\.img\20180727105113115.png)

## 二叉树

### 定义

二叉树(binary tree) 是n个节点的有限集合,该集合有一个根节点和两颗互不相交的左子树和右子树

特点:

- 每个节点最多有两颗子树,所以二叉树中不存在度大于2的节点
- 左子树和右子树是有顺序的,次序布恩那个任意颠倒
- 即使树中某节点只有一颗子树,也要区分他是左子树还是右子树

### 二叉树的五种形态

![这里写图片描述](D:\note\.img\20180727111203962.png)

### 特殊二叉树

#### 斜树

所有节点只有左子树的二叉树叫做左斜树

所有节点只有右子树的二叉树叫做右斜树

#### 满二叉树

所有分支节点都存在左子树和右子树,并且所有叶子都在同一层上的二叉树

![1569472484633](D:\note\.img\1569472484633.png)

1. 叶子只能出现在最下一层
2. 非叶子节点的度一定是2
3. 在同样深度的二叉树中,满二叉树的节点个数最多,叶子数最多

#### 完全二叉树

对一颗有n个节点的二叉树按层序编号,如果编号为i的节点与同样深度的满二叉树中编号为i的节点在二叉树中的位置完全相同,则是完全二叉树

![](D:\note\.img\20180727112538865.png)

满二叉树一定是完全二叉树,完全二叉树不一定是满二叉树

特点:

1. 叶子节点只能出现在最下两层
2. 最下曾的叶子一定集中在左部连续位置
3. 倒数第二层,若有叶子节点,一定都是右部连续位置
4. 如果节点度为1,则该节点只有左孩子,即不存在只有右子树的情况
5. 同样节点数的二叉树,完全二叉树的深度最小

## 二叉树的性质

- 在二叉树的第i层,至多右2的i-1次方个节点

  ![](D:\note\.img\2018072711290314.png)

  第一层: 2的0次方,为1个

  第二层: 2的1次方,为2个

  第三层: 2的2次方,为4个

  第i层: 2的i-1次方

- 深度为k的二叉树最多有2的k次方-1个节点(计算总结点个数)

  如果有一层: 至多1=2的0次方-1个节点

  如果有二层: 至多1+2=2的2次方-1个节点

  如果有三层: 至多1+2+3=2的3次方-1个节点

  如果有i层: 至多1+2+4+...+2的i-1次方=2的i次方-1个节点

- 具有n个节点的完全二叉树的深度为log2N+1

- 对于完二叉树的任意节点i

  对于一颗有n个节点的完全二叉树,其节点按照层序编号进行以此排序,如下图所示

  ![1569477140020](D:\note\.img\1569477140020.png)

  1. 如果i=1,则节点i时二叉树的根,无父节点;如果i>1,则其父节点是i/2(不管该节点是左孩子还是右孩子,都是i/2)
  2. 如果2*i>n,则节点i无左孩子,即该节点为叶子节点
  3. 如果2*i+1>n,则节点i无右孩子

## 完全二叉树的遍历

### 数组实现

![这里写图片描述](D:\note\.img\20180727120134318)

#### 深度优先遍历(前中后序遍历)

- 前序遍历

  先访问根节点,再遍历左子树,再遍历右子树

- 中序遍历

  先遍历左子树,再访问根节点,再遍历右子树

- 后序遍历

  先遍历左子树,再遍历右子树,再访问根节点

代码实现

```java
//完全二叉树的数组实现(前中后序遍历)
public class FullArrayBinaryTree {
    private int[] arr=null;//保存数据
    public FullArrayBinaryTree(int[] arr) {
        this.arr = arr;
    }
    //根据当前节点的index获取其左孩子的index
    public int getLeftChildren(int index) throws Exception {
        if(2*index+1>arr.length-1) return -1;//无左孩子
        return 2*index+1;
    }
    //根据当前节点的index获取其右孩子的index
    public int getRightChildren(int index) throws Exception {
        if(2*index+2>arr.length-1)  return -1;//无右孩子
        return 2*index+2;
    }
    
    //前序遍历
    public void preOrder(int index) throws Exception {
        System.out.print(arr[index]+" ");//访问当前节点

        int leftChildrenIndex = getLeftChildren(index);
        if(leftChildrenIndex!=-1){
            preOrder(leftChildrenIndex);//访问左孩子
        }

        int rightChildrenIndex = getRightChildren(index);
        if (rightChildrenIndex!=-1){
            preOrder(rightChildrenIndex);//访问右孩子
        }
    }
    //中序遍历
    public void inOrder(int index) throws Exception {
        int leftChildrenIndex = getLeftChildren(index);
        if(leftChildrenIndex!=-1){
            inOrder(leftChildrenIndex);//访问左孩子
        }

        System.out.print(arr[index]+" ");//访问当前节点

        int rightChildrenIndex = getRightChildren(index);
        if (rightChildrenIndex!=-1){
            inOrder(rightChildrenIndex);//访问右孩子
        }
    }
    //后序遍历
    public void postOrder(int index) throws Exception {
        int leftChildrenIndex = getLeftChildren(index);
        if(leftChildrenIndex!=-1){
            postOrder(leftChildrenIndex);//访问左孩子
        }

        int rightChildrenIndex = getRightChildren(index);
        if (rightChildrenIndex!=-1){
            postOrder(rightChildrenIndex);//访问右孩子
        }

        System.out.print(arr[index]+" ");//访问当前节点
    }
    //测试
    public static void main(String[] args) throws Exception {
        int[] arr=new int[10];
        for(int i=0;i<10;i++){
            arr[i]=i;
        }
        FullArrayBinaryTree fullArrayBinaryTree = new FullArrayBinaryTree(arr);
        fullArrayBinaryTree.preOrder(0);//前序遍历
        fullArrayBinaryTree.inOrder(0);//中序遍历
        fullArrayBinaryTree.postOrder(0);//后序遍历
    }
}
```

#### 广度优先遍历

数组实现的广度优先遍历就是传入数组的顺序遍历

> 代码略

### 链表实现

![这里写图片描述](D:\note\.img\20180727120527706.png)

#### 深度优先遍历(前中后序遍历)

```java
public class FullLinkBinaryTree {
    Node head;//头节点  
    private class Node{
        Node leftChildren;
        int value;
        Node rightChildren;
        public Node(int value){
            this.value=value;
        }
    }
    //通过数组生成完全二叉树
    public FullLinkBinaryTree(int[] arr){
        ArrayDeque<Node> deque = new ArrayDeque<>();
        head=new Node(arr[0]);
        deque.add(head);
        int i=1;
        while(!deque.isEmpty()){
            Node poll = deque.poll();

            if(i+1>arr.length){
                deque.clear();
                break;
            }
            Node leftChildren=new Node(arr[i++]);
            poll.leftChildren=leftChildren;
            deque.add(leftChildren);

            if(i+1>arr.length){
                deque.clear();
                break;
            }
            Node rightChildren=new Node(arr[i++]);
            poll.rightChildren=rightChildren;
            deque.add((rightChildren));
        }
    }
    //先序遍历
    public void preOrder(Node node){
        if(node==null) return;
        System.out.print(node.value+" ");//访问当前节点
        preOrder(node.leftChildren);//访问左节点
        preOrder(node.rightChildren);//访问右节点
    }
    //中序遍历
    public void inOrder(Node node){
        if(node==null) return;
        inOrder(node.leftChildren);//访问左节点
        System.out.print(node.value+" ");//访问当前节点
        inOrder(node.rightChildren);//访问右节点
    }
    //后序遍历
    public void postOrder(Node node){
        if(node==null) return;
        postOrder(node.leftChildren);//访问左节点
        postOrder(node.rightChildren);//访问右节点
        System.out.print(node.value+" ");//访问当前节点
    }
    //测试
    public static void main(String[] args) {
        int[] arr=new int[10];
        for(int i=0;i<10;i++){
            arr[i]=i;
        }
        FullLinkBinaryTree fullLinkBinaryTree = new FullLinkBinaryTree(arr);
        fullLinkBinaryTree.preOrder(fullLinkBinaryTree.head);//前序遍历
        System.out.println();
        fullLinkBinaryTree.inOrder(fullLinkBinaryTree.head);//中序遍历
        System.out.println();
        fullLinkBinaryTree.postOrder(fullLinkBinaryTree.head);//后序遍历
    }
}
```

#### 广度优先遍历

```java
public class FullLinkBinaryTree {
    Node head;//头节点
    private class Node{
        Node leftChildren;
        int value;
        Node rightChildren;
        public Node(int value){
            this.value=value;
        }
    }
    public FullLinkBinaryTree(int[] arr){
        ArrayDeque<Node> deque = new ArrayDeque<>();
        head=new Node(arr[0]);
        deque.add(head);
        int i=1;
        while(!deque.isEmpty()){
            Node poll = deque.poll();

            if(i+1>arr.length){
                deque.clear();
                break;
            }
            Node leftChildren=new Node(arr[i++]);
            poll.leftChildren=leftChildren;
            deque.add(leftChildren);

            if(i+1>arr.length){
                deque.clear();
                break;
            }
            Node rightChildren=new Node(arr[i++]);
            poll.rightChildren=rightChildren;
            deque.add((rightChildren));
        }
    }
    //广度优先遍历
    public void BFS(Node node){
        if(node==null) {
            System.out.println("null");
            return;
        }

        ArrayDeque<Node> deque = new ArrayDeque<>();
        deque.add(node);
        //如果deque不为空
        while(!deque.isEmpty()){
            Node poll = deque.poll();
            System.out.print(poll.value+" ");

            if(poll.leftChildren!=null) {
                deque.add(poll.leftChildren);//压入左节点
            }

            if(poll.rightChildren!=null){
                deque.add(poll.rightChildren);//压入右节点
            }
        }
    }
    //测试
    public static void main(String[] args) {
        int[] arr=new int[10];
        for(int i=0;i<10;i++){
            arr[i]=i;
        }
        FullLinkBinaryTree fullLinkBinaryTree = new FullLinkBinaryTree(arr);
        fullLinkBinaryTree.BFS(fullLinkBinaryTree.head);//广度优先遍历
    }
}
```

## 二叉搜索树

由于二叉搜索树的定义和特性,他可以高效解决以下问题:

- 查找问题: 二分查找
- 高级结构: 字典结构实现
- 数据变动: 节点的插入,删除
- 遍历问题: 前序,中序,后序和层序遍历
- 数值运算: ceil,floor,找到第n大的元素,找到指定元素在排序好的数组的位置等等

值得一提的是,除了遍历算法,上述各种问题的算法的时间复杂度都是O(log2N)



二叉树搜索树的定义和性质

- 若任意节点的左子树不空,则左子树上所有节点的值均小于该节点的值
- 若任意节点的右子树不空,则右子树上所有节点的值均大于该节点的值
- 任意节点的左,右子树也分别二叉搜索树
- 没有键值相等的节点

> 注意: 二叉搜索树不一定是一个完全二叉树,因此,二叉搜索树不能用数组来存储

### 二叉搜索树的接口定义

```java
//添加的数据不允许重复
public interface MyTreeSet {
    public void build(int[] arr);//构建一颗二叉搜索树
    public void add(Node node,int value);//添加节点
    public Node remove(int value) throws Exception;//删除节点
    public Node find(Node node,int value);//查找节点
    public void update(int beforeValue,int nowValue) throws Exception;//更新节点
    public boolean empty();//判断是否为空
    public Node getFirst(Node node) throws Exception;//获取但不删除最小节点
    public Node getLast(Node node) throws Exception;//获取但不删除最大节点
    public Node pollFirst(Node node) throws Exception;//获取并删除最小节点
    public Node pollLast(Node node) throws Exception;//获取并删除最大节点
}
```

### 二叉搜索树实现

```java
//定义节点类,提供MyTreeSet接口使用
class Node{
    Node leftChildren;
    int value;
    Node rightChildren;
    public Node(int value){
        this.value=value;
    }
}

//实现了一个二叉搜索树
public class MyBinarySearchTree implements MyTreeSet {
    Node root;//根节点
    //使用数组生成一个二叉搜索树
    @Override
    public void build(int[] arr) {
        for(int i=0;i<arr.length;i++){
            add(root,arr[i]);
        }
    }
    //添加一个节点
    @Override
    public void add(Node node,int value) {
        if(root==null){
            root=new Node(value);
            return;
        }
        //不考虑相等的情况,相当于一个set集合
        if(value<node.value){//小于放入左子树
            if(node.leftChildren==null){
                node.leftChildren=new Node(value);
                return;
            }
            add(node.leftChildren,value);
        }else if(value>node.value){//大于放入右子树
            if(node.rightChildren==null){
                node.rightChildren=new Node(value);
                return;
            }
            add(node.rightChildren,value);
        }
    }
    //删除一个节点
    @Override
    public Node remove(int value) throws Exception {
        if(root==null){
            throw new Exception("null");
        }
        Node node =root;
        Node parentNode=null;
        while(node!=null){
            if(value<node.value){
                parentNode=node;
                node=node.leftChildren;
            }else if(value>node.value){
                parentNode=node;
                node=node.rightChildren;
            }else{
                //找到要删除的节点了
                if(parentNode.value>node.value){//要删除的节点是父节点的左子树
                    Node node1=pollLast(node);
                    if(node1==null){
                        //没有右节点
                        parentNode.leftChildren=node.leftChildren;
                    }else{
                        //有右节点
                        parentNode.leftChildren=node1;
                        node1.leftChildren=node.leftChildren;
                        node1.rightChildren=node.rightChildren;
                    }
                }else{//要删除的节点是父节点的右子树
                    if(node.leftChildren==null){
                        parentNode.rightChildren=node.rightChildren;
                    }else{
                        Node node1 = pollLast(node.leftChildren);
                        if(node1==null){
                            //没有左节点
                            parentNode.rightChildren=node.leftChildren;
                            node.leftChildren=node.rightChildren;
                        }else{
                            //有右节点
                            parentNode.rightChildren=node1;
                            node1.leftChildren=node.leftChildren;
                            node1.rightChildren=node.rightChildren;
                        }
                    }
                }
                return node;
            }
        }
        if(node==null){
            throw new Exception("没有找到该值");
        }
        return null;
    }
    //查找节点
    @Override
    public Node find(Node node,int value) {
        if(node==null){
            return null;
        }
        if(value<node.value){
            return find(node.leftChildren,value);
        }else if(value>node.value){
            return find(node.rightChildren,value);
        }else{//相等
            return node;
        }
    }
    //更新节点
    @Override
    public void update(int beforeValue, int nowValue) throws Exception {
        Node node = find(root, beforeValue);
        if(node!=null){
            node.value=nowValue;
        }else {
            throw new Exception("不存在该数值");
        }
    }
    @Override
    public boolean empty() {
        return root==null;
    }
    //获取但不删除最小节点
    @Override
    public Node getFirst(Node node) throws Exception {
        if(root==null){
            throw new Exception("null");
        }
        while(node.leftChildren!=null){
            node=node.leftChildren;
        }
        return node;
    }
    //获取但不删除最大节点
    @Override
    public Node getLast(Node node) throws Exception {
        if(root==null){
            throw new Exception("null");
        }
        while(node.rightChildren!=null){
            node=node.rightChildren;
        }
        return node;
    }
    //获取且删除最小节点
    @Override
    public Node pollFirst(Node node) throws Exception {
        if(node==null){
            throw new Exception("null");
        }
        Node parentNode=null;
        while(node.leftChildren!=null){
            parentNode=node;//备份父节点
            node=node.leftChildren;
        }
        //如果原来node节点就没有左节点
        if(parentNode==null){
            return null;//除了本身,就没有最小值了
        }else{//要删除的节点有右节点
            //删除node节点,并将父节点的左子树指向node节点的右子树(node已经没有左子树了)
            parentNode.leftChildren=node.rightChildren;
            return node;
        }
    }
    //获取且删除最大节点
    @Override
    public Node pollLast(Node node) throws Exception {
        if(node==null){
            throw new Exception("null");
        }
        Node parentNode=null;
        while(node.rightChildren!=null){
            parentNode=node;//备份父节点
            node=node.rightChildren;
        }
        //如果原来node节点就没有右节点
        if(parentNode==null){
            return null;//除了本身,就没有最大值了
        }else{//要删除的节点有左节点
            //删除node节点,并将父节点的右子树指向node节点的左子树(node已经没有右子树了)
            parentNode.rightChildren=node.leftChildren;
            return node;
        }
    }
    @Override
    public String toString() {
        if(root==null) return "null";
        ArrayDeque<Node> arrayDeque = new ArrayDeque<>();
        arrayDeque.add(root);
        StringBuilder sb=new StringBuilder();
        while(!arrayDeque.isEmpty()){
            Node poll = arrayDeque.poll();
            sb.append(poll.value+" ");
            if(poll.leftChildren!=null){
                arrayDeque.add(poll.leftChildren);
            }
            if(poll.rightChildren!=null){
                arrayDeque.add(poll.rightChildren);
            }
        }
        return sb.toString();
    }
    //测试
    public static void main(String[] args) throws Exception {
        int[] arr={67,4,743,327,82,2,79,23,7};
        MyBinarySearchTree myBinarySearchTree = new MyBinarySearchTree();
        //构建一个二叉搜索树
        myBinarySearchTree.build(arr);
        System.out.println(myBinarySearchTree);
        //查找
        Node node = myBinarySearchTree.find(myBinarySearchTree.root, 82);
        System.out.println(node.value);
        //弹出最大值
        Node node1 = myBinarySearchTree.pollLast(myBinarySearchTree.root);
        System.out.println(node1.value);
        System.out.println(myBinarySearchTree);
        //弹出最小值
        Node node2 = myBinarySearchTree.pollFirst(myBinarySearchTree.root);
        System.out.println(node2.value);
        System.out.println(myBinarySearchTree);
        //获取最大值
        Node node3 = myBinarySearchTree.getLast(myBinarySearchTree.root);
        System.out.println(node3.value);
        System.out.println(myBinarySearchTree);
        //获取最小值
        Node node4 = myBinarySearchTree.getFirst(myBinarySearchTree.root);
        System.out.println(node4.value);
        System.out.println(myBinarySearchTree);
        //删除节点
        Node remove = myBinarySearchTree.remove(23);
        System.out.println(remove.value);
        System.out.println(myBinarySearchTree);
    }
}
```

### JDK中二叉搜索树的使用demo

```java
public class JDKBinarySearchTreeDemo {
    public static void main(String[] args) {
        TreeSet<Integer> treeSet = new TreeSet<>();//其实是一个最大最小堆
        treeSet.add(5);
        treeSet.add(2);
        treeSet.add(4);
        Integer pollFirst = treeSet.pollFirst();
        System.out.println(pollFirst);
        Integer pollLast = treeSet.pollLast();
        System.out.println(pollLast);
    }
}
```

## 平衡二叉树(AVL树)

略

## 红黑树

略

## 哈夫曼树

略

## 多叉树

略

# 堆

## 堆的接口定义

```java
public interface MyHeap {
    public void add(int value) throws Exception;//添加元素
    public void build(int[] arr) throws Exception;//通过数组构建最大堆
    public int poll();//获取并删除最大值
    public int peek();//获取但不删除最大值
    public boolean isEmpty();//判空
}
```

## 最大堆

最大堆的每个节点的值都大于等于其左右孩子节点的值,并且它是一个完全二叉树,因此它可以由两种存储方式,一种是数组,一种是链表

### 数组实现

```java
//数组实现最大堆
public class MyArrayMaxHeap implements MyHeap {
    int[] arr;//数据
    int size;//个数
    public MyArrayMaxHeap(int size){
        this.arr=new int[size];
    }
    //交换数组中两个index中的值
    public void swap(int index1,int index2){
        int buff=arr[index1];
        arr[index1]=arr[index2];
        arr[index2]=buff;
    }
    //给定一个index,将数组中的index所在的值,使用shiftUp将其往上调整到合适的位置
    public void shiftUp(int index){
        //如果当前值比父节点大,则往上调整
        while(arr[index]>arr[index/2]){
            swap(index,index/2);
            index=index/2;
        }
    }
    //给定一个index,将数组中的index所在的值,使用shiftDown将其往下调整到合适的位置
    public void shiftDown(int index){
        while(true){
            if(index*2+1>arr.length-1){
                //无左右孩子
                break;
            }else if(index*2+2>arr.length-1){
                //有左孩子
                if(arr[index]<arr[index*2+1]){
                    swap(index,index*2+1);
                }
                index=index*2+1;
            }else{
                //有左右孩子
                int max=Math.max(arr[index*2+1],arr[index*2+2]);
                //如果比两个孩子节点都大,则退出
                if(arr[index]>max){
                    break;
                }

                //哪个大和哪个交换
                if(arr[index*2+1]>arr[index*2+2]){
                    swap(index,index*2+1);
                    index=index*2+1;
                }else{
                    swap(index,index*2+2);
                    index=index*2+2;
                }
            }
        }
    }
    //添加一个元素
    @Override
    public void add(int value) throws Exception {
        if(size>arr.length-1){
            throw new Exception("已满");
        }
        arr[size]=value;//将值放在数组的最后一位
        if(size!=0){
            shiftUp(size);//向上调整放入的值的位置
        }
        size++;
    }
    //通过数据构建最大堆
    @Override
    public void build(int[] arr) throws Exception {
        if(this.arr.length<arr.length) throw new Exception("超出范围");
        for(int i=0;i<arr.length;i++){
            add(arr[i]);
        }
    }
    //获取并删除最大值
    @Override
    public int poll() {
        int buff=arr[0];
        arr[0]=arr[size-1];//将最后一位数据放在最顶端
        //执行shiftDown操作,将顶部数据调整到一个合适的位置
        shiftDown(0);
        size--;
        return buff;
    }
    //获取但不删除最大值
    @Override
    public int peek() {
        return arr[0];
    }
    @Override
    public boolean isEmpty() {
        return size==0;
    }
    @Override
    public String toString() {
        StringBuilder sb=new StringBuilder();
        for(int i=0;i<size;i++){
            sb.append(arr[i]+" ");
        }
        return sb.toString();
    }
    //测试
    public static void main(String[] args) throws Exception {
        int[] arr=new int[]{5,48,154,687,1,3,87,151,94};
        MyArrayMaxHeap maxHeap = new MyArrayMaxHeap(10);
        //根据数组构建一个最大堆
        maxHeap.build(arr);
        System.out.println(maxHeap);
        //添加元素
        maxHeap.add(799);
        System.out.println(maxHeap);
        //获取并删除最大值
        int poll = maxHeap.poll();
        System.out.println(poll);
        System.out.println(maxHeap);
        //获取但不删除最大值
        int peek = maxHeap.peek();
        System.out.println(peek);
        System.out.println(maxHeap);
    }
}
```

### 链表实现

略

## 最小堆

最小堆的每个节点的值都小于等于其左右孩子节点的值,并且它是一个完全二叉树

实现和最大堆相仿

## jdk提供的最小堆的使用demo

```java
public class JDKMaxHeapDemo {
    //JDK提供的最小堆(可自行提供Comparator接口),其名称叫做优先队列
    public static void main(String[] args) {
        PriorityQueue<Integer> heap = new PriorityQueue<>();//使用数组实现的最小堆
        heap.add(5);
        heap.add(7);
        heap.add(2);
        heap.add(9);
        while (!heap.isEmpty()){
            System.out.println(heap.poll());
        }
    }
}
```

# 图

## 图的定义

## 图的遍历

### 深度优先遍历

### 广度优先遍历

## 单源最短路径问题

### 有向无权图

### 有向有权图

# 散列表

通过哈希函数计算查找关键字key,直接得到查找值所在的位置



## 哈希函数的构造方法

- 直接定制法

  如H(key)=a*key+b

  这种构造方法比较简单,均匀,但是有很大限制,仅限与地址大小=关键字集合的情况

- 除留余数法(用的比较多)

  H(key)=key mod p

  > p<=m m为表长

  关键在于p的取值,p应为不大于m的质数或是不含20以下的质因数的合数,这样可以减少地址的重复(冲突)

  比如key = 7，39，18，24，33，21时取表长m为9 p为7 那么存储如下

  ![1569549154295](D:\note\.img\1569549154295.png)

## 哈希冲突的解决方案

不管哈希函数设计的如何巧妙,总会右特殊的key会导致hash冲突,以下是解决hash冲突常用的方法

- 开放地址法(重要)

  略

- 链地址法(重要)

  产生hash冲突后在存储数据后面加一个指针，指向后面冲突的数据

  ![这里写图片描述](D:\note\.img\20180520012305597)

- 公共溢出区法

  建立一个特殊存储空间，专门存放冲突的数据。此种方法适用于数据和冲突较少的情况。

- 再散列法

  准备若干个hash函数，如果使用第一个hash函数发生了冲突，就使用第二个hash函数，第二个也冲突，使用第三个……

## 简单代码实现

```java
public class MyHashTable {
    private TreeMap<String, Integer>[] hashtable;//保存每一个hash函数计算出来后的数据
    private int M;
    private int size;
    public MyHashTable(int M) {
        this.M = M;
        size = 0;
        hashtable = new TreeMap[M];//创建一个数组大小为M的哈希数组
        for (int i=0; i<M; i++) {
            hashtable[i] = new TreeMap<>();
        }
    }
    //默认创建一个数组为97的hashTable
    public MyHashTable() {
        this(97);
    }
    //哈希函数,计算散列值
    public int hash(String key) {
        return (key.hashCode() & 0x7ffffff) % M;
    }
    //获取大小
    public int getSize() {
        return size;
    }
    //添加键值对
    public void add(String key, Integer value) {
        TreeMap<String, Integer> map = hashtable[hash(key)];//先计算hash得到了对应的treemap
        if (map.containsKey(key)) {
            map.put(key, value);
        } else {
            map.put(key, value);
            size++;
        }
    }
    //删除key
    public Integer remove(String key) {
        TreeMap<String, Integer> map = hashtable[hash(key)];
        Integer ret = null;
        if (map.containsKey(key)) {
            ret = map.remove(key);
            size--;
        }
        return ret;
    }
    //修改key对应的值
    public void set(String key, Integer value) {
        TreeMap<String, Integer> map = hashtable[hash(key)];
        if (!map.containsKey(key)) {
            throw new IllegalArgumentException(key+"doesn't exist!");
        }
        map.put(key, value);
    }
    //查询是否包含key
    public boolean contains(String key) {
        return hashtable[hash(key)].containsKey(key);
    }
    //获取key对应的值
    public Integer get(String key) {
        return hashtable[hash(key)].get(key);
    }
    //测试
    public static void main(String[] args) {
        MyHashTable myHashTable = new MyHashTable();
        //添加键值对
        myHashTable.add("like",10);
        myHashTable.add("you",20);
        //获取值
        Integer like = myHashTable.get("like");
        System.out.println(like);
        //获取大小
        int size = myHashTable.getSize();
        System.out.println(size);
        //是否包含key
        boolean contains = myHashTable.contains("you");
        System.out.println(contains);
    }
}
```

## JDK的HashMap的使用demo

```java
public class JDKHashTableDemo {
    public static void main(String[] args) {
        //和HashMap一样,他是线程安全的,而HashMap不是
        //他们内部都是用链表来解决hash冲突
        Hashtable<String, Integer> hashtable = new Hashtable<>();

        hashtable.put("you",10);
        Integer you = hashtable.get("you");
        System.out.println(you);
        int size = hashtable.size();
        System.out.println(size);
    }
}
```

# 算法时间复杂度计算

# 参考文档

[数据结构教程-C语言中文网](http://c.biancheng.net/data_structure/intro/)

[数据结构图文解析C++实现](https://blog.csdn.net/LiuJiuXiaoShiTou/article/details/77095156)

[数据结构知识点](https://blog.csdn.net/jiaoyangwm/article/details/80808235)

[数据结构java实现](https://blog.csdn.net/npz1999/article/details/89460531)