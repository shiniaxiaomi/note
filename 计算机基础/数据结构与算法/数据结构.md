[TOC]

# 线性结构

## 线性表

线性表是一种线性结构,它是由零个或者多个数据元素构成的有限序列; 线性表的特征是在一个序列中,除了头尾元素,每个元素都有且只有一个直接前驱,有且只有一个直接后继

### 定义List接口

```java
public interface MyList {
    public void add(int value);
    public int remove(int index) throws Exception;
    public void update(int index,int value) throws Exception;
    public int get(int index) throws Exception;
    public int size();
}
```

### 数组实现

使用数组简单的实现ArrayList

```java
public class MyArrayList implements MyList {
    private int size=10;//定义数组的初始大小
    private int index=0;//数组索引
    private int[] arr=new int[size];//数组
    @Override
    public void add(int value) {
        if(index>=size){//如果超过数组长度,则扩容
            int[] newArr=new int[size*=2];
            System.arraycopy(arr,0,newArr,0,10);
            arr=newArr;
        }
        arr[index++]=value;
    }
    @Override
    public int remove(int index) throws Exception {
        if(index>this.index-1) throw new Exception("数组越界");//防止数组越界
        int buff=arr[index];
        for(int i=index;i<this.index-1;i++){
            arr[i]=arr[i+1];
        }
        this.index--;
        return buff;
    }
    @Override
    public void update(int index, int value) throws Exception {
        if(index>this.index-1) throw new Exception("数组越界");
        arr[index]=value;
    }
    @Override
    public int get(int index) throws Exception {
        if(index>this.index-1) throw new Exception("数组越界");
        return arr[index];
    }
    @Override
    public int size() {
        return this.index;
    }
    @Override
    public String toString() {
        return Arrays.toString(this.arr);
    }

    public static void main(String[] args) throws Exception {
        MyArrayList myArrayList = new MyArrayList();
        //增
        for(int i=0;i<8;i++){
            myArrayList.add(i);
        }
        System.out.println("增:"+myArrayList);
        //删
        int obj=myArrayList.remove(2);
        System.out.println("删:"+myArrayList);
        //改
        myArrayList.update(4,100);
        System.out.println("改:"+myArrayList);
        //查找
        int i = myArrayList.get(6);
        System.out.println(i);
        //大小
        System.out.println(myArrayList.size());
    }
}
```

### 链表实现

使用链表简单的实现LinkList

```java
public class MyLinkList implements MyList {
    //定义一个节点类
    private class Node{
        Node before;//上一个节点
        int value;//数据
        Node next;//下一个节点
        public Node(int value) {
            this.value = value;
        }
    }

    private Node head=null;//头节点
    private Node indexNode=null;//当前节点
    private int size=0;

    @Override
    public void add(int value) {
        if(head==null){
            Node node=new Node(value);
            head=node;//将head指向node节点
            indexNode=node;//将indexNode指向node节点
        }else{
            Node node=new Node(value);
            indexNode.next=node;//将indexNode的下一个节点指向node
            node.before=indexNode;//将node的上一个节点指向indexNode
            indexNode=node;//将当前节点修改成node
        }
        size++;
    }
    @Override
    public int remove(int index) throws Exception {
        Node node = getNode(index);
        node.before.next=node.next;//要删除节点的上一个节点的下一个指针指向删除节点的下一个node
        size--;
        return node.value;
    }
    @Override
    public void update(int index, int value) throws Exception {
        Node node = getNode(index);
        node.value=value;
    }
    @Override
    public int get(int index) throws Exception {
        Node node=getNode(index);
        return node.value;
    }
    @Override
    public int size() {
        return this.size;
    }
    @Override
    public String toString() {
        if(head==null) return null;
        StringBuilder sb=new StringBuilder();
        Node node=head;
        while (node!=null){
            sb.append(node.value+" ");
            node=node.next;
        }
        return sb.toString();
    }
    //根据索引获取node
    public Node getNode(int index) throws Exception {
        if(index>size-1) throw new Exception("越界");

        Node node=head;
        while(index>0){
            node=node.next;
            index--;
        }
        return node;
    }

    public static void main(String[] args) throws Exception {
        MyLinkList myLinkList = new MyLinkList();
        //增
        for(int i=0;i<10;i++){
            myLinkList.add(i);
        }
        System.out.println(myLinkList);
        //删
        myLinkList.remove(4);
        System.out.println(myLinkList);
        //改
        myLinkList.update(2,100);
        System.out.println(myLinkList);
        //查
        myLinkList.get(6);
        System.out.println(myLinkList);
        //大小
        System.out.println(myLinkList.size());
    }
}
```

## 堆栈

### 定义堆栈接口

```java
public interface MyStack {
    public void push(int value) throws Exception;
    public int pop() throws Exception;
    public int peek() throws Exception;//获取但不删除元素
    public boolean empty();
}
```

### 数组实现

```java
public class MyArrayStack implements MyStack {
    private int size=0;
    private int[] arr=null;
    private int index=0;//当前栈顶的指针

    //创建指定大小的堆栈
    public MyArrayStack(int size) {
        this.size = size;
        this.arr=new int[size];
    }

    @Override
    public void push(int value) throws Exception {
        if(index>size-1) throw new Exception("越界");
        arr[index++]=value;
    }
    @Override
    public int pop() throws Exception {
        if(index<0) throw new Exception("越界");
        return arr[--index];
    }
    @Override
    public boolean empty() {
        return index==0;
    }
    //获取但不删除元素
    @Override
    public int peek() throws Exception {
        if(index<0) throw new Exception("越界");
        return arr[index];
    }
    @Override
    public String toString() {
        StringBuilder sb=new StringBuilder();
        for(int i=0;i<index;i++){
            sb.append(arr[i]+" ");
        }
        return sb.toString();
    }

    public static void main(String[] args) throws Exception {
        MyArrayStack stack=new MyArrayStack(14);
        //push
        for(int i=0;i<10;i++){
            stack.push(i);
        }
        System.out.println(stack);
        //pop
        while(!stack.empty()){
            System.out.println(stack.pop());
        }
    }
}
```

### 链表实现

```java
public class MyLinkStack implements MyStack {
    private Node head=null;//记录一下头节点,方便toString()
    private int size=0;
    private Node indexNode=null;//当前栈顶的指针

    private class Node{
        Node before;
        int value;
        Node next;
        public Node(int value) {
            this.value = value;
        }
    }

    @Override
    public void push(int value) throws Exception {
        if(indexNode==null){
            indexNode=new Node(value);
            head=indexNode;
        }else{
            Node node=new Node(value);
            indexNode.next=node;
            node.before=indexNode;
            indexNode=node;
        }
        size++;
    }
    @Override
    public int pop() throws Exception {
        if(size<0) throw new Exception("越界");
        //如果是头节点
        if(size==1) {
            int value=indexNode.value;
            indexNode=null;//删除节点
            head=null;//头节点置空
            size--;
            return value;
        }

        int value=indexNode.value;
        indexNode.before.next=null;//删除当前节点
        indexNode=indexNode.before;
        size--;
        return value;
    }
    //获取但不删除元素
    @Override
    public int peek() throws Exception {
        if(size<0) throw new Exception("越界");
        return indexNode.value;
    }
    @Override
    public boolean empty() {
        return size==0;
    }
    @Override
    public String toString() {
        if(head==null) return null;
        StringBuilder sb=new StringBuilder();
        Node node=head;
        while(node!=null){
            sb.append(node.value+" ");
            node=node.next;
        }
        return sb.toString();
    }

    public static void main(String[] args) throws Exception {
        MyLinkStack stack=new MyLinkStack();
        //push
        for(int i=0;i<10;i++){
            stack.push(i);
        }
        System.out.println(stack);
        //pop
        while(!stack.empty()){
            System.out.println(stack.pop());
        }
    }
}
```

### JDK中的Stack使用Demo

```java
public class JDKStackDemo {
    public static void main(String[] args) {
        Stack<Object> stack = new Stack<>();
        for(int i=0;i<10;i++){
            stack.push(i);//添加元素
        }
        System.out.println(stack);
        while(!stack.empty()){
            System.out.println(stack.pop());//弹出元素
        }
        Object peek = stack.peek();//只获取但不删除最顶端的元素
        System.out.println(peek);
    }
}
```



## 队列

具有先进先出的特点,所有的新元素都插入到队列的末尾,移出元素都在队列的头部

### 定义Queue接口

```java
public interface MyQueue {
    //正常队列操作
    public void add();
    public void poll();
    public void peek();
    public boolean empty();
}
```

### 定义双端队列(Deque)接口

```java
// 该接口继承自MyQueue接口,并提供了头部和尾部的操作接口
public interface MyDeque extends MyQueue {
    //尾部的添加和获取操作
    public void addLast();
    public void getLast();
    //头部的添加和获取操作
    public void addFirst();
    public void getFirst();
}
```

### 双端队列(Deque)实现

继承自Queue,具有先进先出的特点,支持在头部和尾部添加和删除元素

> 相当于循环队列

#### 数组实现

```java

```

#### 链表实现

```java

```

### 优先队列(PriorityQueue)实现

元素可以按照任意顺序插入,却总是按照排序的顺序检索,也就是说,无论何时调用remove方法,总会获得当前优先队列中的最小元素

优先队列使用了一个高效的数据结构-堆(最大堆和最小堆)

优先队列会实现MyQueue接口,只提供一些普通队列的操作

优先队列的典型应用是任务调度; 每个任务都有优先级,任务以随机顺序添加到优先队列中,每当启动一个新的任务时,都将优先级最高或最低(这个可以自己指定)的任务从队列中删除

该实现可以参考本文`堆`数据结构的实现(最大堆和最小堆)

### JDK中的队列使用Demo

#### 双端队列

```java
public class JDKQueueDemo {
    public static void main(String[] args) {
        //双端队列
        ArrayDeque<Object> arrayDeque = new ArrayDeque<>();
        arrayDeque.addLast(1);//指定加载末尾
        arrayDeque.addLast(2);
        arrayDeque.addLast(3);
        arrayDeque.add(4);//add默认加载尾部
        Object poll1 = arrayDeque.poll();//poll默认弹出头部
        System.out.println(poll1);
        Object last = arrayDeque.getLast();
        System.out.println(last);
        Object first = arrayDeque.getFirst();
        System.out.println(first);
    }
}
```

> 结果: 
>
> last: 3
>
> first: 1

#### 优先队列

```java
public class JDKQueueDemo {
    public static void main(String[] args) {
        //定义比较的规则(按照降序,即最大堆)
        Comparator<Integer> comparator=new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2-o1;
            }
        };
        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>(comparator);//创建优先队列
        priorityQueue.add(1);
        priorityQueue.add(5);
        priorityQueue.add(2);
        priorityQueue.add(4);
        priorityQueue.add(3);
        while (!priorityQueue.isEmpty()){
            Object poll = priorityQueue.poll();
            System.out.println(poll);
        }
    }
}
```

> 乱序插入,获取是从大到小获取(最大堆)
>
> 结果:  5 4 3 2 1

# 树

## 二叉树

### 搜索二叉树

### 平衡二叉树(AVL树)

### 红黑树

## 二叉树的遍历

### 深度优先遍历

### 广度优先遍历

## 多叉树

# 堆

数组实现和链表实现

## 最大堆

## 最小堆

# 图

## 图的定义

## 图的遍历

### 深度优先遍历

### 广度优先遍历

## 单源最短路径问题

### 有向无权图

### 有向有权图

# 散列表

HashMap

# 算法时间复杂度计算

# 参考文档

[数据结构图文解析C++实现](https://blog.csdn.net/LiuJiuXiaoShiTou/article/details/77095156)

[数据结构知识点](https://blog.csdn.net/jiaoyangwm/article/details/80808235)

[数据结构java实现](https://blog.csdn.net/npz1999/article/details/89460531)