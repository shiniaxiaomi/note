[TOC]

# 分治算法

## 设计思想

将一个难以直接解决的大问题,分割成一些规模较小的相同问题,以便逐个击破,分而治之

## 分治策略

对于一个规模为n的问题,若该问题可以容易的解决(比如说规模n较小)则直接解决,否则将其分解为k个规模较小的自问题,这个自问题相互独立且与原问题形式相同,递归的解决这些子问题,然后将各个子问题的解合并得到原问题的解

分治法使用的情况

- 该问题的规模缩小到一定的程度就可以容易的解决

  > 该特征绝大多数问题都可以满足,因为问题的计算复杂性一般是随着问题规模的增加而增加的

- 该问题可以分解为若干个规模较小的相同问题,即该问题具有最优子结构性质

  > 该特征反应了递归的思想

- 利用该问题分解出的子问题的解可以合并为原问题的解

  > 该特征是分治法的关键,如果不具备该条特征,可以考虑使用贪心法或动态规划法

- 该问题所分解出的各个子问题是相互独立的,即子问题之间不包含公共的子子问题

  > 该特征涉及到分治法的效率问题,如果各个自问题是不独立的,则分治法要左许多不必要的工作,重复的解决公共的子问题,此时虽然可用分治法解决,但一般使用动态规划法效率更高

## 分治反的基本步骤

1. 将原问题分解为若干个规模较小,相互独立,与原问题形式相同的子问题
2. 若子问题规模较小则直接解决,否则递归解决各个子问题
3. 将各个子问题的解合并为原问题的解

## 经典问题

- 二分搜索
- 大整数乘法
- 归并排序
- 快速排序
- 汉诺塔

## 代码实现

### 归并排序

![img](.img/.常用五大算法/1024555-20161218163120151-452283750.png)

```java
//归并排序
public class MergeSort {
    //将传入的arr进行排序
    public void sort(int[] arr){
        int[] temp=new int[arr.length];//开辟和原数组一样大的空间
        sort(arr,0,arr.length-1,temp);
    }
    //将arr中[left,right]的内容进行排序
    public void sort(int[] arr,int left,int right,int[] temp){
        if(left<right){
            int mid=(left+right)/2;
            //分治
            sort(arr,left,mid,temp);//先将左边分至最小,并排序好
            sort(arr,mid+1,right,temp);//再将右边分至最小,并排序好
            //归并
            merge(arr,left,mid,right,temp);
        }
    }
    //归并
    public void merge(int[] arr,int left,int mid,int right,int[] temp){
        int i=left;//左指针
        int j=mid+1;//右指针
        int t=0;//临时数组的指针(从零开始装)

        while(i<=mid && j<=right){//两边都还有数值
            if(arr[i]<arr[j]){
                temp[t++]=arr[i++];
            }else{
                temp[t++]=arr[j++];
            }
        }

        //有一边装完之后,就直接把另一半装到临时数据
        //如果右边已经装完了
        while(i<=mid){
            temp[t++]=arr[i++];
        }
        //如果左边已经装完了
        while(j<=right){
            temp[t++]=arr[j++];
        }

        //将临时数组里已经排好序的数据复制会arr
        t=0;//临时数据的索引清零
        while(left<=right){
            arr[left++]=temp[t++];
        }

    }
    //测试
    public static void main(String[] args) {
        int[] arr=new int[]{8,4,5,7,1,3,6,2};
        MergeSort mergeSort = new MergeSort();
        mergeSort.sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```

# 回溯算法

## 定义

回溯算法实际上是一个类似于枚举的搜索尝试过程,主要是在搜索尝试过程中寻找问题的解,当发现已不满足求解条件时,就返回到上一个节点继续尝试别的路径,直到得到解,这个返回的过程就被成为回溯

回溯法使用的深度优先来搜索问题的解,首先从根节点出发,当搜索至某个节点时,先利用剪枝函数判断该节点是否可行(即能够得到问题的解),如果不可行,则跳过对该节点为根的子树继续搜索,逐层向其祖先节点回溯; 如果可行,则进入该子树,继续按深度优先策略搜索

回溯法的基本行为是搜索,搜索过程使用剪枝函数来避免无效的搜索,剪枝函数包括两类:

1. 使用约束函数,剪去不满足约束条件的路径

2. 使用限界函数,剪去不能得到最优解的路径

## 算法一般步骤

1. 针对所给问题,定义问题的解空间,他至少包含问题的一个最优解
2. 确定易于搜索的解空间结构,使得能用回溯法方便搜索整个解空间
3. 已深度优先的方式搜索解空间,并且在搜索过程中使用剪枝函数避免无效搜索

## 经典问题

- 8皇后问题
- 迷宫问题

## 代码实现

8皇后问题

```java

```

# 分支分解算法

# 动态规划算法

# 贪心算法