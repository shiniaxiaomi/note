# 代理模式

代理模式,即有一些操作是交给代理做的,对于被代理的人来说,是无感知的

比如: 明星的经纪人就是他的代理,明星只需要负责唱歌就行,而他的经纪人则帮明星筹办演唱会,收钱,还有演唱会结束后的后续处理工作等

所谓静态代理和动态代理,静态和动态指的是对应的代理类是怎么生成的,是手动编写还是动态生成; 如果是手动编写,那么即使静态代理,因为在编译之前就生成好了代理类; 如果是动态生成, 在编译之前是还没有代理类的代码的,需要在程序运行时动态的生成;

动态生成的好处: 简化了编程,扩展性高

## 静态代理

下面是静态代理的Demo:

创建一个接口:

```java
public interface Perform {
    void sing();
}
```

实现该接口:

```java
public class Star implements Perform {
    @Override
    public void sing() {
        System.out.println("唱歌");
    }
}
```

创建静态代理类:

```java
public class StarProxy implements Perform {
    Perform target;//保存需要被代理的对象(注意,这里需要使用的是接口)
    public StarProxy(Perform target) {
        this.target = target;
    }
    @Override
    public void sing() {
        System.out.println("收钱");
        target.sing();
        System.out.println("结束");
    }
}
```

测试:

```java
public class Test {
    public static void main(String[] args) {
        Perform starProxy = new StarProxy(new Star());
        starProxy.sing();
    }
}
```

运行结果:

```java
收钱
唱歌
结束
```

## 动态代理

在spring中,采用了两种动态代理结合的方式进行创建代理,即jdk动态代理和CGLib动态代理

两者动态代理各有有点:

- jdk动态代理

  需要实现`InvocationHandler`接口,如果没有实现该接口,则不能使用jdk动态代理进行代理了

  jdk动态产生的代理的代价比较小,但是执行时的效率较低

- CGLib动态代理

  不需要实现`InvocationHandler`接口就可以进行动态代理,他是使用ASM来操作字节码重新生成新的类来生成的代理,但是不能对于是`final`的方法就没有办法了

### jdk动态代理

demo如下:

创建接口

```java
public interface Perform {
    void sing();
}
```

实现接口

```java
public class Star implements Perform {
    @Override
    public void sing() {
        System.out.println("sing");
    }
}
```

实现`InvocationHandler`接口

```java
public class StarProxy implements InvocationHandler {

    Perform target;//这里必须使用接口接受,接口具体需要代理的对象

    public StarProxy(Perform target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("收钱");//其他非业务相关的业务逻辑
        Object invoke = method.invoke(target, args);//执行代理对象的方法
        System.out.println("结束");//其他非业务相关的业务逻辑
        return invoke;
    }
}
```

测试

```java
public class Test {
    public static void main(String[] args) {
        //创建java代理类
        Star star=new Star();
      	//参数1:传入类加载器(jdk会缓存已经加载过的类加载器)
      	//参数2:传入需要代理的类梭实现的接口
      	//参数3:传入实现InvocationHandler接口的类
        Perform proxy = (Perform) Proxy.newProxyInstance(Perform.class.getClassLoader(),
                new Class<?>[]{Perform.class}, new StarProxy(star));
        proxy.sing();
    }
}
```

### CGLib动态代理

具体的业务逻辑

```java
public class Star {
    public void sing(){
        System.out.println("唱歌");
    }
}
```

动态产生具体的代理类

```java
public class Test {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();//使用Enhancer类动态的生成代理类
        enhancer.setSuperclass(Star.class);//设置要代理的类
        //设置需要代理前后的操作
        enhancer.setCallback((MethodInterceptor) (obj, method, args1, proxy) -> {
            System.out.println("before method run...");//其他非业务逻辑
            Object result = proxy.invokeSuper(obj, args1);//执行主要的业务逻辑
            System.out.println("after method run...");//其他非业务逻辑
            return result;
        });
        Star proxy = (Star) enhancer.create();//创建代理类

        proxy.sing();
    }
}
```

> 由代码中可以看出,使用CGLib可以很方便的创建出动态代理类,而且其代理类的执行效率比较高(比jdk的动态代理效率高),但是其的创建代理类的成本也会相应的变大(因为他是使用ASM来操作字节码重新生成新的类来生成的代理)















