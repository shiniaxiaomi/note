# 什么是连接池

数据库连接池负责分配,管理和释放数据库的连接,它允许应用程序重复使用一个现有的数据库连接,而不是每次都重新连接

# 为什么要使用连接池

数据库连接是一种有限且昂贵的资源,一个数据库连接对象均对应一个物理数据库连接,每次操作都打开一个物理连接,使用完都关闭连接,这样造成系统的性能低下; 

数据库连接池的解决方法是在应用程序启动时建立足够的数据库连接,并将这些连接组成一个连接池,然后动态的对池中的连接进行管理(申请,使用和释放); 对于多个连接池中连接数的并发请求,应该在请求队列中排队等待; 并且应用程序可以根据池中连接的使用率,动态的增加或减少池中的连接数; 连接池技术尽可能多的重用了消耗内存的资源,大大节省了内存,提高了服务器的效率,使得其能够服务更多的请求;

# 传统连接和连接池的区别

## 不使用连接池的情况

下面以Mysql为例,执行一个sql命令,如果不使用连接池,需要经过以下几个步骤:

1. TCP建立连接的三次握手
2. Mysql认证的三次握手
3. 正真的sql执行
4. Mysql的关闭
5. TCP关闭的四次握手

过程图如下:

![img](/Users/yingjie.lu/Documents/note/.img/2018092721591380)

它有以下几个缺点:

1. 网络IO较多
2. 数据库的负载较高
3. 响应时间较长及QPS较低
4. 应用频繁的创建连接和关闭连接，导致临时对象较多，GC频繁
5. 在关闭连接后，会出现大量TIME_WAIT 的TCP状态（在2个MSL之后关闭）

## 使用连接池的情况

使用连接池的步骤:

第一次访问的时候,需要建立连接,但是之后的访问,均会复用之前创建的连接,直接执行sql语句

优点:

1. 较少了网络开销
2. 系统的性能会有一个实质的提升
3. 没了麻烦的TIME_WAIT状态

# 连接池的工作原理

## 原理介绍

连接池主要由三部分组成,分别为:

1. 连接池的建立

   一般在系统初始化时，连接池会根据系统配置建立，并在池中创建了几个连接对象，以便使用时能从连接池中获取。连接池中的连接不能随意创建和关闭，这样避免了连接随意建立和关闭造成的系统开销 

2. 连接池中连接的使用管理

   连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响 

   其管理策略是 :

   1. 当客户请求数据库连接时，首先查看连接池中是否有空闲连接，如果存在空闲连接，则将连接分配给客户使用；如果没有空闲连接，则查看当前所开的连接数是否已经达到最大连接数，如果没达到就重新创建一个连接给请求的客户；如果达到就按设定的最大等待时间进行等待，如果超出最大等待时间，则抛出异常给客户
   2. 当客户释放数据库连接时，先判断该连接的引用次数是否超过了规定值，如果超过就从连接池中删除该连接，否则保留为其他客户服务 
   3. 该策略保证了数据库连接的有效复用，避免频繁的建立、释放连接所带来的系统资源开销 

3. 连接池的关闭

   当应用程序退出时，关闭连接池中所有的连接，释放连接池相关的资源 

## 主要参数

使用连接池时，要配置以下参数 :

1. 最小连接数：是连接池一直保持的数据库连接,所以如果应用程序对数据库连接的使用量不大,将会有大量的数据库连接资源被浪费.
2. 最大连接数：是连接池能申请的最大连接数,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作
3. 最大空闲时间
4. 获取连接超时时间
5. 超时重试连接次数

## 注意点

1. 并发问题

   为了使连接管理服务具有最大的通用性，必须考虑多线程环境，即并发问题; 可以使用 synchronized锁或Lock锁进行同步

2. 事务处理

   当2个线程共用一个连接Connection对象，而且各自都有自己的事务要处理时候，对于连接池是一个很头疼的问题，因为即使Connection类提供了相应的事务支持，可是我们仍然不能确定那个数据库操作是对应哪个事务, 这是由于我们有２个线程都在进行事务操作而引起的。为此我们可以使用每一个事务独占一个连接来实现，虽然这种方法有点浪费连接池资源但是可以大大降低事务管理的复杂性 

3. 连接池的分配与释放

   合理的分配与释放，可以提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度 

   对于连接的管理可使用一个List。即把已经创建的连接都放入List中去统一管理。每当用户请求一个连接时，系统检查这个List中有没有可以分配的连接。如果有就把那个最合适的连接分配给他；如果没有就抛出一个异常给用户，List中连接是否可以被分配由一个线程来专门管理

4. 连接池的配置与维护

   连接池中到底应该放置多少连接，才能使系统的性能最佳？系统可采取设置最小连接数（minConnection）和最大连接数（maxConnection）等参数来控制连接池中的连接 

   比方说，最小连接数是系统启动时连接池所创建的连接数。如果创建过多，则系统启动就慢，但创建后系统的响应速度会很快；如果创建过少，则系统启动的很快，响应起来却慢 

   > 可以在开发时，设置较小的最小连接数，开发时项目启动起来会快，而在系统实际使用时设置较大的，因为这样对访问客户来说速度会快些。最大连接数是连接池中允许连接的最大数目 

   如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接,以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。 

# 常用连接池

以下是这些常用数据库连接池最新版本的发布时间:

| 数据库连接池 | 最新版本 | 发布时间 |
| :----------: | :------: | :------: |
|     C3P0     | 0.9.5.2  |   2015   |
|     DBCP     |  2.2.0   |   2017   |
|    Druid     |  0.11.0  |   2017   |
|   HikariCP   |  2.7.6   |   2018   |

从表中可以看出,C3P0已经很久没有更新了,DBCP更新速度很慢,基本处于不活跃的状态,而Druid和HikariCP处于活跃状态的更新中

## 彻底死掉的c3p0

c3p0差不多已经彻底死掉了,在真实的项目中很少会用c3p0数据源,因为它在性能上的缺点同步与其他几款数据源以及你个相差甚远,而且最致命的是c3p0的架构设计过于负责,很难重构,所以c3p0已经彻底退出了历史舞台

但是我们平时在测试项目或写一些Demo的时候可以使用c3p0连接池,因为它使用方便

---

使用:

1. 引入maven依赖

   ```xml
   <dependency>
       <groupId>c3p0</groupId>
       <artifactId>c3p0</artifactId>
       <version>0.9.1.2</version>
   </dependency>
   ```

2. 配置连接池

   ```xml
   <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
       <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
       <property name="jdbcUrl" value="jdbc:mysql://127.0.0.1:3306|"></property>
       <property name="user" value="root"></property>
       <property name="password" value="123456"></property>
   </bean>
   ```

## 咸鱼翻身的DBCP

DBCP（DataBase Connection Pool）属于Apache顶级项目Commons中的核心子项目 ,在 Tomcat内部就集成了DBCP连接池, 它内部依赖于Commons中的另一个子项目Pool , 连接池最核心的“池”，就是由Pool组件提供的，因此，DBCP的性能实际上就是Pool的性能 

因为核心功能依赖于Pool，所以DBCP本身只能做小版本的更新，真正大版本的更迭则完全依托于pool ;  有很长一段时间，pool都还是停留在1.x版本，这直接导致DBCP也更新乏力。很多依赖DBCP的应用在遇到性能瓶颈之后，别无选择，只能将其替换掉，DBCP忠实的使用者tomcat就在其tomcat 7.0版本中，自己重新设计开发出了一套连接池(Tomcat JDBC Pool) ;  好在, 14年2月份，DBCP也终于迎来了自己的2.0版本，基于新的线程模型全新设计的“池”让DBCP重焕一新, 虽然和新一代的连接池相比仍有一定差距，但差距并不大，DBCP2.x版本已经稳稳达到了和新一代产品同级别的性能指标(见下图)

 ![img](/Users/yingjie.lu/Documents/note/.img/20180927220228256)

 DBCP终于靠Pool咸鱼翻身 ,  但长时间的等待已经完全消磨了用户的耐心，与新一代的产品项目相比，DBCP没有任何优势，试问，谁会在有选择的前提下，去选择那个并不优秀的呢？也许，现在还选择DBCP2的唯一理由，就是情怀吧 

## 性能无敌的HikariCP

 HikariCP号称“性能杀手” ,下面是官方提供的数据:

![img](/Users/yingjie.lu/Documents/note/.img/20180927220242652)

不光性能强劲,稳定性也不差:

![img](/Users/yingjie.lu/Documents/note/.img/20180927220255616)

那它是怎么做到如此强劲的呢？官网给出的说明如下： 

- 字节码精简：优化代码，直到编译后的字节码最少，这样，CPU缓存可以加载更多的程序代码；
- 优化代理和拦截器：减少代码，例如HikariCP的Statement proxy只有100行代码；
- 自定义数组类型（FastStatementList）代替ArrayList：避免每次get()调用都要进行range check，避免调用remove()时的从头到尾的扫描；
- 自定义集合类型（ConcurrentBag）：提高并发读写的效率；
- 其他缺陷的优化，比如对于耗时超过一个CPU时间片的方法调用的研究（但没说具体怎么优化）。

 可以看到，上述这几点优化, HakariCP在性能上的优势应该是得到共识的

## 功能全面的Druid

Druid是阿里众多优秀开源项目中的一个,  它除了提供性能卓越的连接池功能外，还集成了SQL监控，黑名单拦截等功能, 用它自己的话说，Druid是“为监控而生” ;

下图是官方提供的性能测试数据:

![img](/Users/yingjie.lu/Documents/note/.img/20180927220312706)

现在项目开发中，都比较倾向于使用Durid，它不仅仅是一个数据库连接池，它还包含一个ProxyDriver，一系列内置的JDBC组件库，一个SQL Parser。 

---

Druid 相对于其他数据库连接池的优点:

强大的监控特性，通过Druid提供的监控功能，可以清楚知道连接池和SQL的工作情况 

1. 监控SQL的执行时间、ResultSet持有时间、返回行数、更新行数、错误次数、错误堆栈信息 
2. SQL执行的耗时区间分布。什么是耗时区间分布呢？比如说，某个SQL执行了1000次，其中0~1毫秒区间50次，1~10毫秒800次，10~100毫秒100次，100~1000毫秒30次，1~10秒15次，10秒以上5次。通过耗时区间分布，能够非常清楚知道SQL的执行耗时情况；
3. 监控连接池的物理连接创建和销毁次数、逻辑连接的申请和关闭次数、非空等待次数、PSCache命中率等。

---

使用:

1. 引入maven依赖

   ```xml
   <dependency>
       <groupId>com.alibaba</groupId>
       <artifactId>druid</artifactId>
       <version>1.1.8</version>
   </dependency>
   ```

2. 配置连接池

   ```xml
   <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
       <property name="driver" value="com.mysql.jdbc.Driver"></property>
       <property name="url" value="jdbc:mysql://127.0.0.1:3306"></property>
       <property name="name" value="root"></property>
       <property name="password" value="123456"></property>
   </bean>
   ```

# 参考文档

[csdn-数据库连接池学习笔记](https://blog.csdn.net/CrankZ/article/details/82874158)  