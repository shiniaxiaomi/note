[TOC]

# 线程介绍

## 进程和线程

- 进程

  进程是资源分配的最小单位

  每个进程都有独立的代码和数据空间(进程上下文),进程间的切换会有较大的开销,一个进程包含多个线程

- 线程

  线程是cpu调度的最小单位
  
  同一类线程共享代码和数据空间,每个线程有独立的运行栈和程序计数器(PC),线程切换开销小

线程和进程一样,共分为5个阶段: 创建,就绪,运行,阻塞,终止

多进程是指操作系统能同时运行多个任务(程序)

多线程是指同一程序中有多个顺序流在执行

在java中要实现多线程,有三种方法

1. 继承Thread类
2. 实现Runnable接口
3. 实现Callable接口,并与Future类和线程池结合使用

## 并行和并发

并行: 指在同一时刻,有多条命令在多个处理器上同时执行,所以无论从微观还是从宏观上看,二者都是一起执行的

![img](.img/.多线程/7557373-72912ea8e89c4007.webp)

并发: 指在同一时刻只能有一条命令执行,但多个指令被快速的轮换执行,使得在宏观上具有同时执行的效果,但在微观上,只是把事情分成若干段,使得每一段能够快速的交替执行,而并不是同时执行

![img](.img/.多线程/7557373-da64ffd6d1effaac.webp)

# 线程创建

## 继承Thread类

继承Thread类,并重写父类的run()方法

通过Thread类的start()方法启动线程

```java
public class Thread1 extends Thread {
    @Override
    public void run() {
        for(int i=0;i<100;i++){
            System.out.println(i);
        }
    }
    public static void main(String[] args) {
        new Thread1().start();
    }
}
```

## 实现Runnable接口

实现Runnable接口,并实现run()方法

将实现了Runnable接口的类传入Thread构造函数中,并调用start()方法启动线程

```java
public class RunnableThread implements Runnable {
    @Override
    public void run() {
        for(int i=0;i<100;i++){
            System.out.println(i);
        }
    }
    public static void main(String[] args) {
        new Thread(new RunnableThread()).start();
    }
}
```

## 实现Callable接口

略

# 线程状态转换

## 状态转换图

![](.img/.多线程/clip_image001.png)

## 线程的5种状态

1. 新建状态(New)

   创建后尚未启动(未调用start()方法)

2. 就绪状态(Runnable)

   可以被运行,等待cpu分配时间片

3. 运行状态(Running)

   正在运行

4. 阻塞状态(Blocked)

   1. 等待阻塞: 线程位于等待池中,该线程已经释放了锁,等待被调用notify()方法来唤醒,从而进入锁池中
   2. 同步阻塞: 线程位于锁池中,和锁池中的线程争夺对象锁,争夺到锁后会进入到就绪状态
   3. 其他阻塞: 当调用sleep,join或者I/O请求时,会发生该种阻塞,该阻塞不会释放锁

5. 死亡状态(Dead)

   线程运行完毕或发生异常后终止

## 线程的生命周期

1. 当使用Thread构造函数创建线程后,该线程就会处于**新建状态**

2. 在**新建状态**时调用该线程的start()方法后,该线程会进入到锁池中,开始和锁池中的线程争夺锁,如果争夺到锁了,就会进入到**就绪状态**

   > 锁池指的是对象锁的锁池,每个对象都会有对应的一个锁池(如果把该对象当作一把锁,一般使用Object对象)
   >
   > 调用start()方法后,进入到锁池,一般来说是没有锁的,那么该线程就会直接进入到就绪状态,如果有锁,但是锁池中只有该线程,那么该线程会直接拿到锁,并进入到就绪状态,等到分配cpu时间片

3. 当线程处于**就绪状态**时,且系统调度选中了该线程(即将cpu的时间片分配给了该线程),则该线程就会进入到运行状态,那么该线程的run()方法中的代码也就被执行了

4. 当线程位于**运行状态**时

   1. 当时间片使用完,则重新变为**就绪状态**,该线程不会释放锁
   2. 当**调用sleep()**方法时,该线程进入**阻塞状态**(其他阻塞状态),该线程不会释放锁,等到sleep时间到达后,该线程又会从阻塞状态变为**就绪状态**,往复执行
   3. 当**调用join()**方法时,该线程进入**阻塞状态**(其他阻塞状态),该线程不会释放锁,等待加入的线程运行完毕之后,该线程会从**阻塞状态**变为**就绪状态**,往复执行
   4. 当**发生I/O请求**时,该线程进入**阻塞状态**(其他阻塞状态),该线程不会释放锁,当I/O请求完成后,该线程会从**阻塞状态**变为**就绪状态**,往复执行
   5. 当对象锁**调用wait()**方法时,该线程会进入到该对象锁的等待池中,该线程会释放锁,当再次调用该对象锁的notify()或notifyAll()时,该线程会从该对象锁的等待池进入到该对象锁的锁池,开始和锁池中的线程争夺该对象锁
   6. 当对象锁**调用wait(Long millis)**方法时,该线程会进入到该对象锁的等待池中,该线程会释放锁,等到等待的时间到达后,该线程会自动的从该对象锁的等待池中进入到该对象的锁池中,开始和锁池中的线程争夺该对象锁
   7. 当run()方法中代码执行完毕后,线程进入**死亡状态**

# 线程调度

在java中,实现线程的调度有6种方式:

1. 设置线程的优先级: thread.setPriority()

2. 线程睡眠: Thread.sleep(1000)

3. 线程等待: Object类中的wait()方法

4. 线程让步: Thread.yield()方法

5. 线程加入: thread.join()方法

6. 线程唤醒: Object类中的notify()方法


## 设置线程的优先级-setPriority()

调整线程的优先级,优先级高的线程会获得比较多的运行机会

java线程的优先级用整数表示,取值范围是1~10,Thread类有以下三个静态常量:

```java
//线程可以具有的最高优先级，取值为10
static int MAX_PRIORITY
//线程可以具有的最低优先级，取值为1
static int MIN_PRIORITY
//分配给线程的默认优先级，取值为5  
static int NORM_PRIORITY        
```

Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级

每个线程都有默认的优先级,主线程的默认优先级为Thread.NORM_PRIORITY(即为5)

线程的优先级有继承关系,比如A线程中创建了B线程,那么B将和A具有相同的优先级

## 线程睡眠-sleep()

使用Thread.sleep(long millis)方法,可以使得线程从运行状态转到阻塞状态; 当睡眠时间结束之后,该线程的状态就会从阻塞状态变为就绪状态

当调用sleep()方法后,当前的线程不会释放锁

## 线程等待-wait()

当对象锁调用wait()方法

- 当调用wait()方法后,线程会进入到对象锁的等待池中,直到该对象锁调用notify或notifyAll方法时,才会从等待池中进入到锁池中

- 当调用wait(long millis)方法后,,线程会进入到对象锁的等待池中,直到等待时间到达后,该线程会自动的从等待池中进入到锁池中

当被调用wait()方法后,线程会释放掉当前的锁

```java
public class Test1 {
    public static void main(String[] args) throws Exception {
        Object lock=new Object();//对象锁
        //创建并启动线程
        new Thread(()->{
            for(int i=0;i<6;i++){
                synchronized (lock){
                    if(i==3){//当i等于3的时候线程等待
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    System.out.println("thread1:"+i);
                }
            }
        }).start();

        Thread.sleep(1000);
        synchronized (lock){//延时1秒后唤醒lock对象的所有等待的线程
            lock.notifyAll();
        }

    }
}
```

## 线程让步-yield()

调用yield()方法的线程会让出cpu,即把当前正处于运行状态的线程变为就绪状态,给其他线程执行的机会

> 但是让出cpu后,不一定就会让其他线程执行,这个要看系统的调度,有可能该线程调用yield()方法让出cpu后,下一次的系统调用还是选中了该cpu(即又是该cpu获得了cpu的时间片),那么就又是该线程执行

## 线程加入-join()

让调用join()方法的线程加入到该线程中,该线程进入到阻塞状态,直到加入的线程执行完毕之后,该线程的状态由阻塞状态变为就绪状态,等待cpu时间片的分配

> 即等到加入的线程执行完毕后再继续执行

```java
public class Runnable3 implements Runnable{
    int b=0;

    @Override
    public void run() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("线程执行结束,结果是:"+ b++);
    }

    public static void main(String[] args) throws InterruptedException {
        Runnable3 runnable3 = new Runnable3();
        Thread thread = new Thread(runnable3);
        thread.start();

        thread.join();//使用join使得子线程合并到主线程,直到子线程执行完毕之后主线程再继续执行
        System.out.println("main获取到的结果是:"+runnable3.b);
    }
}
```

> 运行结果: 
>
> 线程执行结束,结果是:0
>
> main获取到的结果是:1

## 线程唤醒-notify(),notifyAll()

对象锁调用notify()方法,唤醒该对象锁的等待池中的任意一个线程; 如果对象锁调用notifyAll()方法,则唤醒该对象锁的等待池中的所有线程

唤醒后的线程会从该对象锁的等待池进入到该对象锁的锁池

# 锁的分类

## 分类概览

从宏观上分:

- 乐观锁
- 悲观锁

从类型上分:

- 自旋锁(升级后变为自适应自旋锁)
- Synchronized的三种状态锁
  1. 偏向锁(默认状态)
  2. 轻量级锁
  3. 重量级锁

## 按宏观分类

### 乐观锁

总是假设最好的情况,每次去按数据的时候都认为别人不会修改,所以不会上锁,但是在更新的时候会判断以下在此期间别人有没有去更新此数据,可以使用版本号机制或者CAS算法实现; 乐观锁使用关于多读的应用类型,这样可以提高吞吐量,像数据库提供的类似于write_condition机制,其实都是乐观锁; 在java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种CAS的实现;

> 像偏向锁和轻量级锁都是乐观锁

#### 版本号机制

为了实现乐观锁,可以引入一个版本号的概念,来巧妙的解决这个问题

示例:

假设账号信息表中有一个version字段,当前值为1,账户余额balance为100

1. 操作员A准备修改数据,将余额变为50,则先从数据中读取数据,此时得到了数据{version:1,balacne:100}

2. 此时操作员B也读取了数据,数据为{version:1,balacne:100}

3. 操作员A修改数据,将数据修改为{version:2,balacne:50},并提交到了数据库完成了更新,更新条数返回1,表示更新成功

   A的update语句:`update table set version=version+1,balace=50 where version=1`

4. 此时操作员B也要修改数据,将账户余额修改为20,此时数据库中的指已经变为{version:2,balacne:50},当B执行下面的update语句时,更新条数返回0,因为此时版本已经变为2,所以更新无效,B只能再去数据库中读取最新的数据,在重复上述操作

   B的update语句:`update table set version=version+1,balace=20 where version=1`

总结: 

更新数据前先去数据库读取最新数据,修改时在版本号中+1,条件是version等于之前查询的version

- 如果更新条数为1,则更新成功,表示之前没有人更新过数据(即没有冲突),此时的版本就会递增1,对于其他人来说,他们之前读取的数据就已经不是最新的,那么他们再更新时就会失败,需要重新读取数据;
- 如果更新条数为0,则更新失败,表示之前有人更新数据,版本号已经被递增了,所以需要重新读取最新数据后再做更新操作

#### CAS算法实现

CAS即Compare And Swap(比较与交换),是一种著名的无锁算法; 无锁编程,即不使用锁(没有线程被阻塞)的情况下实现多线程之间的变量同步,所以也叫非阻塞同步(Non-blocking Synchronization); 

CAS算法涉及到三个操作数:

1. 需要读写的内存值V
2. 进行比较的值A
3. 拟写入的新值B

当且仅当V的值等于A时,CAS通过原子方式用新值B来更新V的值,否则不会执行任何操作(比较和替换是一个navtive的原子操作); 一般情况下,这时一个自选操作,即当V不等于A时,则不断的重试

### 悲观锁

总是假设最坏的情况,每次拿数据的时候都认为别人会修改数据,所以每次拿数据时都会上锁,这样别人想拿这个数据时就会被阻塞,直到拿到锁; 传统的关系型数据库里面就用到了很多这种锁机制,比如行锁,表锁,写锁等,都是在操作之前先上锁; java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现

悲观锁使用多写的场景(即经常的发生冲突),如果使用乐观锁,那么会导致不断的重试,反倒降低了性能

> 像重量级锁就是悲观锁

## 按类型分类

### 自旋锁

线程从就绪状态到阻塞状态之间的相互转化是比较消耗资源的,所以为了减少这个资源的消耗,我们通过自旋锁来解决该问题; 

> 如果线程没有获得锁,那么该线程本应该进入到阻塞状态,但是现在自旋锁的做法是先判断是否获取了锁,如果没有,则循环等待,直到获取了锁;这样就保证了该线程不会进入到阻塞状态,而是一直在就绪状态和运行状态相互的转化(cpu时间片用完就变为就绪状态,获得cpu时间片就判断是否获得锁,如果没有则循环等待,往复执行)

自旋锁的实现

```java
public class SpinLock {
    private AtomicReference<Thread> cas = new AtomicReference<Thread>();
    public void lock() {
        Thread current = Thread.currentThread();
        // 利用CAS
        while (!cas.compareAndSet(null, current)) {
            // DO nothing
        }
    }
    public void unlock() {
        Thread current = Thread.currentThread();
        cas.compareAndSet(current, null);
    }
}
```

> lock()方法利用了CAS,当第一个线程A获取锁的时候,能够成功获取到,不会进入while循环,如果此时线程A没有释放锁,另一个线程B又来获取锁,此时由于不满足CAS,所以就会进入while循环,不断判断是否满足CAS,直到A线程调用unlock方法释放了该锁

#### 自旋锁的缺点

1. 如果某个线程持有锁的时间过长,就会导致其他等待获取锁的线程进入循环等待,消耗cpu,使用不当会造成cpu使用率极高
2. 上面实现的自旋锁是不公平的,即无法满足等待时间最长的线程优先获取锁; 不公平的锁就会存在"线程饥饿"问题

#### 自旋锁的优点

1. 自旋锁不会是线程状态发生切换,一直处于用户态,即线程一直都是active的; 不会使线程进入阻塞状态,减少了不必要的上下文切换,执行速度快

#### 如何解决自旋锁的公平性的问题

自旋锁的公平性问题如下:

> 无法满足等待时间最长的线程优先获取锁

解决思路:

> 每当有线程获取锁的时候,就给该线程分配一个递增的id,我们称之为排队号,每当有线程释放锁时,就会让排队号最大的线程获得锁; 由于排队的越久,就数字越大,所以就保证了等待最久的线程最先获取到锁,就实现了公平性

### 自适应自旋锁

自适应锁意味着自旋的时间不再固定了,而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的:

- 如果在同一个锁对象上,自旋等待港方成功获得过锁,并且持有锁的线程正在运行中,那么虚拟机就会认为这次自旋也很有可能再次成功,进而它将允许自旋等待时间相对更长
- 相反,如果对于某个锁,自旋很少成功获得过,那么在以后要获得这个锁时将可能较少自旋时间甚至省略自旋过程,以避免浪费处理器资源

自适应自旋锁解决的是"锁竞争时间不确定"的问题; JVM很难感知到确切的锁竞争时间,而交给用户分析该时间就违反了JVM的设计初衷; 自适应自旋假定不同线程持有同一个锁对象的时间基本相当,竞争程度趋于稳定,因此,可以根据上一次自旋的时间与结果调整下一次自旋的时间

缺点:

自适应自旋锁没有解决根本问题,只是相对优化了自旋锁; 但是如果默认的自旋时间和次数设置不合理(过高或过低),那么自适应的过程将很难收敛到合适的值

### synchronized的三种锁

#### 偏向锁

在没有锁竞争的情况下,即使用锁的线程就只有一个,那么每次加锁就显得非常浪费资源; 

偏向锁的目的是减少无竞争且只有一个线程使用锁的情况下,减轻加锁带来的性能消耗; 

> 轻量级锁每次申请锁和释放锁都至少需要一次CAS,但偏向锁只有初始化时需要一次CAS

偏向锁**假定将来只有第一个申请锁的线程会使用锁(不会有其他线程再来申请锁)**,因此,只需要在Mark Word中使用CAS算法来更新占用锁的线程id,如果更新成功,则偏向锁获取锁成功,记录该锁的状态为偏向锁,以后该线程再访问时,就判断Mark Word的锁标志位为偏向锁,并且判断其中的ThreadId是不是当前线程的id,如果是,则零成本的直接获取锁,如果不是,说明有其他线程竞争,则该锁会膨胀为轻量级锁

#### 轻量级锁

轻量级锁不是用来代替传统的重量级锁的,而是在没有多线程竞争的情况下,使用轻量级锁能够减少性能消耗,但是当多个线程竞争锁时,轻量级锁会膨胀为重量级锁

轻量级锁的加锁过程(简单描述):

> 线程进入代码块前,先判断是否时轻量级锁,如果是,且未获得锁,则进行自旋,如果自旋一定次数后还未获得锁,则轻量级锁会膨胀为重量级锁

#### 重量级锁

即当有其他线程占用锁时,当前线程会进入阻塞状态(锁池,等待锁的释放)

# 关键字

## synchronized

synchronized锁的不是代码,锁的是对象

### 使用对象锁的两种方法

同步代码块

```java
synchronized (this){//this就是对象锁,表示对象锁为当前实例对象
    ...
}
//或者
synchronized (lock){//lock就是对象锁
    ...
}
```

同步非静态方法

```java
//锁是当前对象的实例对象(就是调用该方法的对象)
public synchronized void m1(){
}
```

### 使用类锁的两种方法

同步代码块

```java
synchronized (类名.class){//锁是小括号()中的类对象(Class对象)
    ...
}
```

同步静态方法

```java
//锁是当前对象的类对象(Class对象)
public static synchronized void m1(){
}
```

### 类锁和对象锁的同步情况

对象锁如果是不同的对象,是锁不住的;而类锁只要是同一个类,就能够锁住

- 类锁

  当new了不同对象(都属于同一个类),类锁还能够保持同步的性质(因为一些不同的对象的类锁都是同一把锁)

  > 类锁最本质的就是虽然是不同对象,但是Class类对应的同时同一把锁,所以同步性质能够保持; 如果使用静态变量当作锁(不同对象也只对应同一个静态变量),那么同步性质也能够保持,如:
  >
  > ```java
  > public static Object lock=new Object();//创建一个静态的对象锁
  > //这样使用多个不同对象也是能够保持同步性质的
  > synchronized(lock){
  >     ...
  > }
  > ```

- 对象锁

  当new了不同对象(都属于同一个类),每个对象都会当前各自对象的this对象锁,那么线程争夺的就不是同一把锁,那么同步性质就会失效

  > 这里说的只限于synchronized(this)的情况下

### 锁分配和膨胀过程

#### 锁的膨胀过程描述

1. 标记为偏向锁

   一个对象刚开始实例化,没有任何线程来访问它的时候,它是可偏向的,意味着它现在认为只可能有一个线程访问它,所以第一个线程访问它是,它会偏向这个线程,此时,对象持有偏向锁,偏向第一个线程,这个线程在修改对象头成为偏向锁的时候使用CAS操作,并将对象头中的ThreadID改成当前线程id,之后再次访问这个对象时,只需要对比ID,不需要再使用CAS进行操作,就可以获取到锁

2. 偏向锁升级为轻量级锁

   一旦有第二个线程访问这个对象时,因为偏向锁不会主动释放,所以第二个线程可以看到对象为偏向状态,这时表明在这个对象上已经存在竞争了,检查原来持有该对象锁的线程是否依然存活,如果已经灭亡,则可以将对象变为无锁状态,然后重新偏向新的线程,如果原来的线程依然存活,则马上获取那个线程的操作栈,检查该对象的使用情况,如果任然需要持有偏向锁,则偏向锁升级为轻量级锁(**偏向锁就在这个时候升级为轻量级锁**),如果不存在使用了,则可以将对象恢复成无锁状态,然后重新偏向

3. 轻量级锁升级为重量级锁

   轻量级锁认为竞争存在,但是竞争的程度很轻,一般两个下称对于同一个锁的操作都会操作,或者说稍微等待一下(自旋),另一个线程就会释放锁; 但是当自旋超过一定的此属,或者一个线程持有锁,一个在自旋,又有第三个线程来访时,轻量级锁就会膨胀为重量级锁,重量级锁使得除了拥有锁的线程意外的线程都阻塞,防止cpu空转

#### 锁的膨胀过程图

![img](.img/.%E5%A4%9A%E7%BA%BF%E7%A8%8B/4491294-e3bcefb2bacea224.png)

> 该图很大,需要另外打开该图片放大进行查看

补充说明:

- CAS记录owner时，*expected == null*，`newValue == ownerThreadId`，因此，**只有第一个申请偏向锁的线程能够返回成功，后续线程都必然失败**（部分线程检测到可偏向，同时尝试CAS记录owner）。
- **内置锁只能沿着偏向锁、轻量级锁、重量级锁的顺序逐渐膨胀**，不能“收缩”。这基于JVM的另一个假定，“*一旦破坏了上一级锁的假定，就认为该假定以后也必不成立*”

另外，当重量级锁被解除后，需要唤醒一个被阻塞的线程，这部分逻辑与ReentrantLock基本相同

上图把锁膨胀的过程描述的很详细,也有Mard Word的图解,看懂上图后,再来看《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》中的简化版流程图就能看懂了：

![img](.img/.%E5%A4%9A%E7%BA%BF%E7%A8%8B/4491294-345a15342fad119a.webp)

## volatile

https://blog.csdn.net/u012723673/article/details/80682208

## atomic包

它是使用CAS来保证原子性操作，从而达到线程安全的目的。

竞争激烈时能维持常态，比Lock性能好；只能同步一个值

https://blog.csdn.net/qq_34871626/article/details/81411815

https://www.cnblogs.com/wanghaoyang/p/11041303.html

## Locks

可中断锁



## J.U.C

# 线程通讯

# 线程池

# 参考文档

[Java多线程学习（吐血超详细总结）](https://blog.csdn.net/Evankaka/article/details/44153709)

https://blog.csdn.net/qq_41665476/article/details/80225592







 