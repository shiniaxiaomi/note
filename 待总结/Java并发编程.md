## 并发

参考链接：https://www.jianshu.com/p/235c777d862c

### Java并发基础

线程和进程的区别：

线程是系统运行调度的最小单位，进行可以包含多个线程

---

目前的处理器核心越来越多，使用多线程能有更快的响应时间，并能有更好的编程模型。 

---

线程的状态：

1. new：初始化状态，还未运行
2. runnable：运行状态，已经调用了start方法
3. blocked：阻塞状态（当遇到synchronized同步块时）
4. waiting：等待状态（当调用wait方法后，释放锁）
5. time_waiting：超时等待状态（当调用sleep方法后，不是放锁）
6. terminated：终止状态（run方法执行结束）

### 并发机制的底层实现

在Java中实现并发有两种方式：

1. volatile+CAS
2. synchronized

---

volatile实现同步的两条原则：

1. Lock前缀指令会引起工作内存中的变量回写到主内存
2. 一个工作内存变量回写到内存会导致其他线程中的变量失效，因此需要重新去主内存中读取

---

synchronized实现同步

- 对于 普通同步方法，锁是 当前实例对象。
- 对于 静态同步方法，锁是 当前类的Class对象。
- 对于 同步方法块，锁是 Synchonized括号里配置的对象。

---

Synchronized在JVM中的实现原理

JVM基于进入和退出Monitor对象来实现方法同步和代码块同步

- 代码块同步时使用monitorEnter和monitorExit指令实现
- 方法同步时使用标识方法为同步来实现

monitorEnter和monitorExit指令时在编译后插入到同步代码块的开始和结束位置

JVM要保证每个monitorEnter必须有对应的monitorExit与之配对

任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorEnter指令时，将会尝试获取对象所对应的monitor的所有权，则尝试获取对象的锁

---

Java对象头

锁信息都是存放在对象头中的

---

锁的4种状态

- 无锁状态
- 偏向锁状态
- 轻量级锁
- 重量级锁

### 保证线程安全的三个要素

原子性，可见性，有序性

在java中共有两种方式能够保证线程安全：

1. volatile+CAS

   volatile保证了有序性和可见性，CAS保证了原子性

2. synchronized

   synchronized关键字能够保证只有一个线程操作一个资源，因而保证了原子性，可见性和有序性

---

如何实现原子操作：

1. 处理器级别实现原子操作

   使用处理器提供的一个`LOCK＃`信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存 

2. JVM层面实现原子操作

   1. 使用CAS保证原子性

      存在的问题：ABA问题，循环时间长开销大问题

   2. 使用锁（synchronized）

      锁机制保证了只有获得锁的线程才能够操作锁定的内存区域 

### Java内存模型（JMM）

JMM全程为Java Memory Model

Java线程通信由Java内存模型控制， JMM 决定一个线程对共享变量的写入何时对另一个线程可见。 

---

JMM定义了线程和主内存之间的抽象关系：

线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，它存储了需要读写的共享变量的副本

![image-20200521181832970](D:\note\.img\image-20200521181832970.png)

从上图来看，线程A和线程B需要通信的话，需要经历一下步骤：

1. 线程A 把本地内存A 中的共享变量副本 刷新到 主内存中
2. 线程B 去读取主内存中的 共享变量A，并保存到本地内存B中

从整体来看，这两个步骤实质上是线程A向线程B发送消息，而通信必须经过主内存。

JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性的保证。

---

从源代码到指令序列的重排序

在执行程序的时候，为了提高性能，编译器和处理器常常会对指令做重排序。

- **编译器优化的重排序** ：编译器在 **不改变单线程程序语义** 的前提下，可以重新安排语句的执行顺序。
- **指令级并行的重排序** : 现代处理器采用 **并行技术** 来将**多条指令重叠执行**，**如果不存在数据依赖性**，处理器可以改变对应机器指令的执行顺序。
- **内存系统的重排序** : 由于处理 使用缓存 和 读写缓冲区 ，这使得加载和存储操作看上去可能乱序执行。

![image-20200521193505935](D:\note\.img\image-20200521193505935.png)

 上图中的 1 属于 `编译器重排序`，2 和 3 属于 `处理器重排序`。这些重排序可能会导致多线程程序出现内存可见性问题。 



对于编译器重排序， JMM的编译器重排序规则 **会禁止特定类型的编译器重排序**。
 对于处理器重排序，JMM的处理器重排序规则 **会要求编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序**。





锁竞争

并发容器

并发工具类

线程池

Executor框架