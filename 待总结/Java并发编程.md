# 并发

参考链接：https://www.jianshu.com/p/235c777d862c

## Java并发基础

线程和进程的区别：

线程是系统运行调度的最小单位，进行可以包含多个线程

---

目前的处理器核心越来越多，使用多线程能有更快的响应时间，并能有更好的编程模型。 

---

线程的状态：

1. new：初始化状态，还未运行
2. runnable：运行状态，已经调用了start方法
3. blocked：阻塞状态（当遇到synchronized同步块时）
4. waiting：等待状态（当调用wait方法后，释放锁）
5. time_waiting：超时等待状态（当调用sleep方法后，不是放锁）
6. terminated：终止状态（run方法执行结束）

## 并发机制的底层实现

在Java中实现并发有两种方式：

1. volatile+CAS
2. synchronized

---

volatile实现同步的两条原则：

1. Lock前缀指令会引起工作内存中的变量回写到主内存
2. 一个工作内存变量回写到内存会导致其他线程中的变量失效，因此需要重新去主内存中读取

---

synchronized实现同步

- 对于 普通同步方法，锁是 当前实例对象。
- 对于 静态同步方法，锁是 当前类的Class对象。
- 对于 同步方法块，锁是 Synchonized括号里配置的对象。

---

Synchronized在JVM中的实现原理

JVM基于进入和退出Monitor对象来实现方法同步和代码块同步

- 代码块同步时使用monitorEnter和monitorExit指令实现
- 方法同步时使用标识方法为同步来实现

monitorEnter和monitorExit指令时在编译后插入到同步代码块的开始和结束位置

JVM要保证每个monitorEnter必须有对应的monitorExit与之配对

任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorEnter指令时，将会尝试获取对象所对应的monitor的所有权，则尝试获取对象的锁

---

Java对象头

锁信息都是存放在对象头中的

---

锁的4种状态

- 无锁状态
- 偏向锁状态
- 轻量级锁
- 重量级锁

## 保证线程安全的三个要素

原子性，可见性，有序性

在java中共有两种方式能够保证线程安全：

1. volatile+CAS

   volatile保证了有序性和可见性，CAS保证了原子性

2. synchronized

   synchronized关键字能够保证只有一个线程操作一个资源，因而保证了原子性，可见性和有序性

---

如何实现原子操作：

1. 处理器级别实现原子操作

   使用处理器提供的一个`LOCK＃`信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存 

2. JVM层面实现原子操作

   1. 使用CAS保证原子性

      存在的问题：ABA问题，循环时间长开销大问题

   2. 使用锁（synchronized）

      锁机制保证了只有获得锁的线程才能够操作锁定的内存区域 

## Java内存模型（JMM）

JMM全程为Java Memory Model

Java线程通信由Java内存模型控制， JMM 决定一个线程对共享变量的写入何时对另一个线程可见。 

---

JMM定义了线程和主内存之间的抽象关系：

线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，它存储了需要读写的共享变量的副本

![image-20200521181832970](D:\note\.img\image-20200521181832970.png)

从上图来看，线程A和线程B需要通信的话，需要经历一下步骤：

1. 线程A 把本地内存A 中的共享变量副本 刷新到 主内存中
2. 线程B 去读取主内存中的 共享变量A，并保存到本地内存B中

从整体来看，这两个步骤实质上是线程A向线程B发送消息，而通信必须经过主内存。

JMM通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性的保证。

---

从源代码到指令序列的重排序

在执行程序的时候，为了提高性能，编译器和处理器常常会对指令做重排序。

- **编译器优化的重排序** ：编译器在 **不改变单线程程序语义** 的前提下，可以重新安排语句的执行顺序。
- **指令级并行的重排序** : 现代处理器采用 **并行技术** 来将**多条指令重叠执行**，**如果不存在数据依赖性**，处理器可以改变对应机器指令的执行顺序。
- **内存系统的重排序** : 由于处理 使用缓存 和 读写缓冲区 ，这使得加载和存储操作看上去可能乱序执行。

![image-20200521193505935](D:\note\.img\image-20200521193505935.png)

 上图中的 1 属于 `编译器重排序`，2 和 3 属于 `处理器重排序`。这些重排序可能会导致多线程程序出现内存可见性问题。 



对于编译器重排序， JMM的编译器重排序规则 **会禁止特定类型的编译器重排序**。
 对于处理器重排序，JMM的处理器重排序规则 **会要求编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序**。

---

happens-before原则

在jdk5之后，java使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，则这两个操作必须要存在happens-before关系。

happens-before规则如下：

- 程序顺序规则：一个线程中的每个操作，happens-before（发生在之前）与该线程中的任意后续操作

- 监视器规则：对一个锁的解锁，happens-before（发生在之前）与随后这个锁的解锁

- volatile变量规则：对于一个volatile域的写，happens-before（发生在之前）域任意后续对这个volatile域的读

- 传递性：A happens-before B，B happens-before C，则A happens-before C

- start()规则：如果`线程A`执行操作`ThreadB.start()`（启动`线程B`），那么`A线程`的`ThreadB.start()`操作`happens-before`于`线程B`中的任意操作。

  join()规则：如果`线程A`执行操作`ThreadB.join()`并成功返回，那么`线程B`中的任意操作`happens-before`于`线程A`从`ThreadB.join()`操作成功返回。

---

volatile的内存语义

理解volatile特性的一个好方法是把对volatile变量的单个读/写，看成是 使用同一个锁 对这些单个读/写操作做了同步

volatile变量特性：

- 可见性：总是能看到（任意线程）对这个volatile变量最后的写入
- 有序性：防止指令重排序

volatile写的内存语义：当写一个volatile变量时，JMM会把线程对应的本地内存中的共享变量刷新到主内存

volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量

---

volatile内存语义的实现：

为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。

 以下是 JMM 针对 **编译器** 制定的 `volatile`重排序规则表 ：

| 是否能重排序           | 第二个操作：普通读/写 | 第二个操作：volatile读 | 第二个操作：volatile写 |
| ---------------------- | :-------------------: | :--------------------: | :--------------------: |
| 第一个操作：普通读/写  |                       |                        |        NO（#）         |
| 第一个操作：volatile读 |        NO（*）        |        NO（*）         |      NO（#）（*）      |
| 第一个操作：volatile写 |                       |        NO（&）         |        NO（#）         |

- 当第二个操作为volatile写时，不管第一个是什么操作，都不能重排序。

  这个规则保证了在volatile写之前的操作不会被重排序到volatile写之后

- 当第一个操作为volatile读时，不管第二个是什么操作，都不能重排序。

  这个规则保证了在volatile读之后的操作不会被重排序到volatile读之前。

- 当第一个操作为volatile写，第二操作为volatile读时，不能重排序。

> （*）的为一组，（#）的为一组，（&）为单独一个



为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特别类型的处理器重排序

对于编译器来说，发现一个最优布置来最小化插入内存屏障的总数几乎不可能，所以，JMM采取保守策略。

下面时基于保守策略的JMM内存屏障插入策略：

- 在每个volatile写操作的前面插入一个StoreStore屏障，后面插入一个StoreLoad屏障
- 在每个volatile读操作的前面插入一个LoadLoad屏障，把后面插入一个LoadStore屏障

> 当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升

---

锁的内存语义

锁时Java并发并称中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。

当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。和volatile写类似

当线程获取锁时，JMM会把线程对应的本地内存职位无效，和volatile读类似



锁释放和锁获取的内存语义总结：

- 线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了消息（线程A对共享变量所做的修改）
- 线程B获取一个锁，实质上是线程B接受了之前某个线程发出的消息
- 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。

---

final域的内存语义

对于final域，编译器和处理器要遵守两个重排序规则

- 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序
- 初次读一个包含final域的对象的引用，与随后初次读取这个final域，这两个操作之间不能重排序

写`final域` 的重排序规则禁止把`final 域`的写重排序到构造函数之外。

读 `final域` 的重排序规则是，在一个线程中，初次读对象引用与初次读该对象包含的 `final域`，JMM禁止处理器重排序这两个操作

---

happens-before

 `happens-before` 是 **JMM** 最核心的概念 

 重排序规则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。 

`happens-before`关系的定义如下：

- 如果一个操作`happens-before`另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
- 两个操作之间存在`happens-before`关系，并不意味着Java平台的具体实现必须要按照`happens-before`关系指定的顺序来执行。如果重排序之后的执行结果，与按`happens-before`关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。

---

### JMM的内存可见性保证

按程序类型，Java程序的内存可见性保证可以分为下列3类：

-  **单线程程序**：不会出现内存可见性问题。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（`0`、`null`、`false`）。
-  **正确同步的多线程程序**：程序的执行将具有顺序一致性。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。
-  **未同步/未正确同步的多线程程序**：JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（`0`、`null`、`false`）。

---

双重检查锁：

```java
private volatile static Instance instance;
public static Instance getInstance() {
    if (instance == null) {
        synchronized (Instance.class) {
            if (instance == null) {
                instance = new Instance();
            }
        }
    }
    return instance;
}
```

在`new Instance()`创建对象时会被分为三步：

```java
memory = allocate();　　// 1：分配对象的内存空间
ctorInstance(memory);　 // 2：初始化对象
instance = memory;　　 // 3：设置instance指向刚分配的内存地址
```

因为可能存在指令重排序，所以代码中的2和3可能会被重排序，则instance就先被赋值内存地址，在初始化对象

当被赋值内存地址且还没初始化对象时，在锁外面的线程判断install不为空，就可能直接返回了还为初始化的对象

所以，需要在字段中添加volatile关键字防止指令重排

## 对象头

普通对象

- 对象头(markword)
- 类型指针(class pointer)
- 实例数据(instance data)
- 对齐(padding)

![image-20200522134926514](D:\note\.img\image-20200522134926514.png)

`markword`数据对于不同的锁来说,存储的数据是不一样的,但是我们可以看到,他们的`markword`的最后两位都是存储锁标志位有关的信息:

- 先看最后两位，如果是00，则是轻量级锁，如果是10，则是重量级锁
- 如果是01，再看最后第三位
  - 如果是0，则是无锁状态
  - 如果是1，则是偏向锁状态

## 锁升级

无锁状态：markword后三位是`001`

---

当第一个线程访问时，将锁对象的markword最后第三位修改为1，变为`101`，前面的其他位记录偏向线程的id等信息

---

如果有两个线程竞争锁对象，那么偏向锁就升级为轻量级锁，将锁对象的markword的后两位修改为`00`，标记为轻量级锁，剩余的其他位用于记录指向持有锁的线程中的`Lock Record`地址

当发生锁竞争时，线程通过CAS+自旋操作将自己的`Lock Record`地址写入到锁对象的对象头中

- 如果写入成功，则表示该线程持有该锁
- 如果写入失败，则线程进行自旋并不断尝试

---

当锁竞争非常激烈时，会升级为重量级锁，将锁对象的markword的后两位修改为`10`，标记为重量级锁。

重量级锁是通过操作系统层面实现的，操作系统将没竞争到锁的线程阻塞（即从用户态转换为内核态，实际上是保存在一个EntryList中），当锁被释放后，操作系统会从EntryList中随机选择一个线程，让其恢复运行状态

---

## Lock接口

`ReentrantLock`实现了`Lock`接口

Lock接口中包含了最主要的两个方法：lock和unlock

### ReentrantLock

`ReentrantLock`内部实现了抽象的AQS类（AbstractQueuedSynchronizer）

AQS中有一个双端队列，用于存放正在等待的线程，遍历队列，分别让等待线程通过CAS尝试获取锁



`ReentrantLock`通过继承AQS实现了公平锁和非公平锁：

- 公平锁：根据操作系统的调度来让线程持有锁
- 非公平锁：根据线程加入等待队列中的时间先后让线程优先持有锁

### Condition接口

- condition中的await()对应Object中的wait()方法

- condition中的singal()对应Object中的notify()方法
- 调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用













并发容器和框架

12个原子类

并发工具类

线程池

Executor框架