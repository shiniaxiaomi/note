## 介绍

面试和简历还有两个重要区别：

第一，面试是一个双向互动的过程，简历是单方向呈现。
第二，简历介绍应是倒叙为好，但面试正相反。当你面向面试官时，应按照时间的顺序从前往后讲，先讲你上大学的教育经历，之后从你参加工作，一直讲到现在，因为面试官要听到你整个成长的经历。否则，面试官会有一种很错乱的感觉。

 1.做过什么。介绍个人履历。 把自己曾经做过的事情说清楚，对应时间节点的工作单位、工作地点、工作岗位、担任职务、工作内容等，尤其是对最近几年做过的事情要重点来说。较早之前的工作经验，或者学习的经验可以一带而过，要把握“重点突出”的原则。 

2.做成过什么。介绍个人业绩。把自己在不同阶段做成的有代表性的事情介绍清楚，注意两点：一是与应聘岗位需要的能力相关的业绩多介绍，不相关的一 笔带过或不介绍，因为面试官关注的是对用人单位有用的业绩；二要注意介绍你个人的业绩而不是团队业绩，要把自己最精彩的一两段业绩加以重点呈现，因为用人 单位要招聘的是你，而不是你过去的团队。否则，不仅无益而且只是成本，因为必然挤占其他重要的展示自己与互相交流的时间。
 3.特长是什么。注意介绍自己最擅长的一定要与应聘的岗位密切相关，主要是围绕专业特长来介绍。除专业特长以外的特长，如果特别突出可以介绍，但要点到为止。 

---

我本专业不是计算机，所以是自学的计算机，在大二下的时候开始自学，学习了1年之后在大三下时进入了吉利实习，在实习期间，学习到了很多东西自学不会涉及到的内容，比如版本管理，代码质量检查，项目的自动化部署等内容

毕业之前，就顺利的在吉利工作，其中做了三个项目，第一个项目是订单预测系统，第二个项目是BPM流程数据中心系统，第三个是汽车ECU诊断升级系统，每个项目待的时间都不长，但是每次换项目后，每个项目的技术栈我都会去不断的了解和学习，在期间还做了自己的个人博客，用于记录学习过程中的心得和一些问题，用于回顾复习。

其中在BPM流程数据中心项目中，需要进行框架版本的升级，在升级过程中出现了bean冲突问题，因此我在完成任务后，对springioc进行了深入的了解和学习，因此对spring相关的内容算是比较了解



## 集合

在Java集合中，总共分为两类：Map接口和Collection接口

在Map接口中：

1. 线程安全：HashTable，ConcurrentHashMap
2. 非线程安全：HashMap（散列），TreeMap（堆）

在Collection接口中，又分为三类：List，Set，Queue

1. List：
   1. 线程安全：Vector，Stack，CopyOnWriteArrayList（读多写少）
   2. 非线程安全：ArrayList（数组），LinkedList（链表）
2. Set
   1. 线程安全：CopyOnWriteArraySet（读多写少）
   2. 非线程安全：HashSet（通过HashMap实现），TreeSet（通过TreeMap实现）
3. Queue
   1. 线程安全：ArrayBlockingQueue，LinkedBlockingQueue，PriorityBlockingQueue（最小堆）
   2. 非线程安全：ArrayDeque（双端队列，循环数组），PriorityQueue（优先队列，最小堆）

## IO

BIO

BIO是面向流的,而NIO是面向缓冲区的 

字节流：InputStream，OutputStream，

字符流：Reader，Wirter

面向流可以理解成是水流(Stream),从其他地方引水,需要先建立水管(建立连接),然后水就从水管中流出(数据从IO流中获得) 

---

NIO

channel（火车），Selector（哨兵），Buffer（集装箱）

面向缓冲区(Buffer)可以理解成是火车的集装箱,火车载物时,需要等待集装箱中的货物装的差不多之后,再一次性的进行运输,其中的Selector可以理解成哨兵,用来监视火车有没有到达,如果到达了,就通知员工(线程)来将火车的货物卸下来,而其中的Channel就可以理解成是铁轨,火车需要铁轨才能行驶 

---

AIO

异步IO

## 设计模式

开闭原则：

对扩展开放，对修改关闭

1. 提高代码复用性
2. 提高代码维护性

---

创建型模式：

1. 单例模式：确保只有一个实例，并提供一个全局访问点（双重检查锁）

   ```java
   private volatile static Instance instance;
   public static Instance getInstance() {
       if (instance == null) {
           synchronized (Instance.class) {
               if (instance == null) {
                   instance = new Instance();
               }
           }
       }
       return instance;
   }
   ```

2. 工厂方法模式：定义一个创建对象的接口，但由子类决定要实例化哪个类，让实例化推迟到子类决定

结构型模式：

1. 适配器模式： 将一个类的接口，转换成期望的另一个接口，它可以让原本两个不兼容的接口能够完成对接。 
2. 代理模式： 给一个对象提供一个代理，并由代理对象控制对原对象的引用 ，之后只需要和代理对象操作即可

行为型模式：

1. 模板方法模式： 在一个方法中定义一个骨架，而将一些具体步骤延迟到子类中实现
2. 观察者模式： 定义了对象之间的一对多的依赖关系，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新
3. 迭代器模式： 提供一种方法顺序访问一个聚合对象中的各个元素，而不是暴露其内部的表示 （iterator）
4. 责任链模式：将一个请求沿着对象所组成的链来传递

## 网络编程

Socket，ServerSocket

TCP，UDP

使用Java写过代理服务器

## 并发

[Java并发编程笔记](D:\note\.img\Java并发编程.md)

并发基础

1. 线程基础
2. 线程和进程的区别
3. 线程状态

并发机制的底层实现

1. volatile+CAS
2. synchronized关键字
3. Java对象头
4. 锁的4中状态

保证线程安全的三种要素

1. 原子性
2. 可见性
3. 有序性

Java内存模型（JMM）

1. 主内存和工作内存
2. 指令重排序

锁竞争

并发容器

并发工具类

线程池

Executor框架

## jvm

## 算法

1. 排序算法
   1. 插入排序（稳定，O(n)）
   2. 冒泡排序（稳定，O(n)）
   3. 选择排序（不稳定，O(n2)）
   4. 归并排序（稳定，O(nlogn)）
   5. 快速排序（不稳定，O(nlogn)）
2. 查找算法
   1. 顺序查找
   2. 二分查找
3. 常用算法
   1. 回溯算法
   2. 归并算法
   3. 贪心算法
   4. 动态规划
   5. 分支限界算法

## spring

springioc原理

1. 如果我们有实现了`BeanFactoryPostProcessor`接口的类，那么spring会首先去实例化并注册这些实现类，然后并循环调用他们的`postProcessBeanFactory(ConfigurableListableBeanFactory var1)`方法，在该方法中可以获取到所有bean的定义，可以进行动态的修改

2. 接下来实例化并注册实现了

   `InstantiationAwareBeanPostProcessor`

   接口的类，该接口中包含了很多bean生命周期回调一些方法，如实例化前后的回调，初始化前后的回调，自动装配前后的回调

   （该接口继承了`BeanPostProcessor`接口，因此具有了初始化前后的回调的方法）

3. 接下来循环所有的单例bean，挨个的进行实例化初始化，并在实例化前后，初始化前后回调我们之前已经设置的后置处理器

   1. 实例化前回调（postProcessBeforeInstantiation）

   2. 执行构造方法进行实例化

   3. 实例化后回调（postProcessAfterInstantiation）

   4. 自动装配

   5. 初始化前回调(postProcessBeforeInitialization)

      > 其中会执行@PostStructure标注的方法

   6. 执行bean的初始化操作

      > 执行InitializingBean接口的afterPropertiesSet方法

   7. 初始化后回调（postProcessAfterInitialization）

---

bean的生命周期

1. 实例化前回调（postProcessBeforeInstantiation）

2. 执行构造方法进行实例化

3. 实例化后回调（postProcessAfterInstantiation）

4. 自动装配

5. 初始化前回调(postProcessBeforeInitialization)

   > 其中会执行@PostStructure标注的方法

6. 执行bean的初始化操作

   > 执行InitializingBean接口的afterPropertiesSet方法

7. 初始化后回调（postProcessAfterInitialization）

---

循环依赖问题

假设A依赖B，B依赖A

1. 先创建A实例，第一次调用getSingleton方法时，标记A正在创建，然后调用A的无参构造方法创建A实例，然后正常的初始化A，在自动装配的时候发现需要B，此时发现B还没有被创建，则去创建B
2. 创建B实例，第一次调用getSingletion方法时，标记B正在创建，然后调用B的无参构造方法创建B实例，然后正常的初始化B，在自动装配的时候发现需要A，发现A已经被创建（因为之前已经标记A正在创建，所以不会再继续创建A，而是可以直接获取到A实例），然后就把A装配到B中，那么B就创建好了
3. 当B创建好之后，A继续自动装配，将B装配到A中，那么A就创建好了

---

springaop与代理

spring中有两种代理，一个是jdk代理，一个是cglib代理，spring默认使用的是jdk代理

- 当使用`@Aspect`注解和`execution`表达式时,则使用Cglib动态代理
- 当使用`@Transactional`注解时,则使用Cglib动态代理
- 如果使用`ProxyFactory`来创建动态代理,则会使用JDK动态代理

---

spring是在哪一步生成的代理类：

在初始化后回调后创建代理类并返回，因为在这一步bean已经初始化完成，对应的依赖和属性都已经初始化完成

## springmvc

主要流程

用户发送请求到DispatchServlet，然后前端控制器根据request中的请求路径查询已经映射的处理器，然后将请求交给对应的处理器适配器处理，处理前会调用拦截器的PreHandler方法，处理后会调用拦截器的PostHandler方法进行拦截

在处理器适配器中:

1. 先处理请求中的参数，并进行数据绑定

2. 根据响应的消息类型分为两种
   1. 如果直接返回消息，则通过消息转换器将数据写入到消息体中，然后直接返回给客户端（可以使用@ResponseBody进行标注）
   2. 如果返回的是页面
      1. 生成并返回ModelAndView对象
      2. 通过视图解析器解析后返回给客户端

---

线程安全问题：

在springmvc中，是线程不安全的，所以我们尽量不要在Controller中使用共享变量，如果一定要使用，则使用ThreadLocal来进行包装，以保证线程安全

## mybatis

一级缓存和二级缓存

默认只开启一级缓存， 一级缓存只是相对于同一个SqlSession而言，只有在参数和SQL完全一样的情况下 才会使用一级缓存中的数据

在xml中配置 `<cache/> `标签即可开启二级缓存，那么xml中所有的select语句都将被缓存，执行增删改操作时会刷新二级缓存

---





spring cloud alibaba
mysql
Redis
Rabbitmq