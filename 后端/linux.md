[TOC]

# 简介

是一个操作系统,和Windows、UNIX一样属于比较流行的操作系统

## linux和unix的联系

windows和linux都参考了unix,先有unix,才有的liunx

- Unix的历史

  在当时需要一个分时操作系统,然后以肯•汤普森为首的贝尔实验室研究人员就开发了unix系统,Multi 是大的意思，大而且繁；而 Uni 是小的意思，小而且巧。这是 UNIX 开发者的设计初衷，这个理念一直影响至今。

- Linux的历史

  Linux内核最初由李纳斯•托瓦兹（Linus Torvalds）开发的,之后作者公开了代码,使得所有可以一起完善linux,到现在只有 2% 的 Linux 核心代码是由李纳斯•托瓦兹自己编写的,但他保留了选择新代码和需要合并的新方法的最终裁定权

- Unix和Linux的关系
  - UNIX 是 Linux 的父亲;
  - Unix依赖硬件,而且是商业产品,不公开; 

  - Linux不依赖硬件,而且是开源产品;


- Unix/Linux系统结构

  ![山东省](.img/.linux/2-1P926160U0153.jpg)

  总共分为3个层次:

  - 底层(系统内核)

    内核层是 UNIX/Linux 系统的核心和基础，`它直接附着在硬件平台之上，控制和管理系统内各种资源`（硬件资源和软件资源），有效地组织进程的运行，从而扩展硬件的功能，提高资源的利用效率，为用户提供方便、高效、安全、可靠的应用环境。

  - 中间层(shell层)

    Shell 层是与用户直接交互的界面。用户可以在提示符下输入命令行，由 Shell 解释执行并输出相应结果或者有关信息,我们可以利用系统提供的丰富命令可以快捷而简便地完成许多工作

  - 高层(应用层)

    应用层提供基于 X Window 协议的图形环境。												

- Linux的优点
  - 有很多好用且免费的软件
  - 有良好的可移植性及灵活性
  - 优良的稳定性和安全性
  - 支持几乎所有的网络协议及开发语言

## linux发行版

所有的linux发行版中,他们的内核都是一样的,是由李纳斯•托瓦兹开发,不同的是他们各自自带了一些不同的软件,系统安装界面和管理工具等

> 内核指的是一个提供设备驱动、文件系统、进程管理、网络通信等功能的系统软件，内核并不是一套完整的操作系统，它只是操作系统的核心。

- 发行版
  - Red Hat Linux

    包括RHEL（Red Hat Enterprise Linux，收费版本）和 `CentOS`（RHEL 的社区克隆版本，免费版本）

  - Ubuntu Linux

    界面友好，容易上手，对硬件的支持非常全面，是目前最适合做桌面系统的 Linux 发行版本,并且免费提供

  - ...

- 发行版选择
  - 如果需要一个服务器系统,需要比较稳定的CentOS或者RHEL
  - 如果需要一个桌面系统,可以选择Ubuntu

## 桌面环境

- KDE 桌面系统
  - 优点：KDE 几乎是最先进最强大的桌面环境，它外观优美、高度可定制、兼容比较旧的硬件设备
  - 缺点：Kmail 等一些组件的配置对新手来说过于复杂。
- GNOME 桌面环境
  - 优点：简单易用，可通过插件来扩展功能。
  - 缺点：对插件的管理能力比较差，也缺少其它桌面环境拥有的许多功能。
- Unity
  - 优点：界面简洁直观，可以通过第三方工具来深度定制，而且使用了平视显示器（HUD）等新技术。
  - 缺点：默认的定制功能比较差劲，通知机制一般。

查看桌面环境

`echo $DESKTOP_SESSION`

# 安装

- 使用VMware虚拟机安装linux

- 选好镜像,一路next

- 在配置网络的时候,选择NAT模式

  网络模式选择

  - 桥接模式

    虚拟机的网卡和本机的物理网卡都连到VMnet0 虚拟交换机上,相当于虚拟机和主机连了一根网线

  - NAT模式

    虚拟机的网卡和本机的虚拟网卡连接到 VMnet8 虚拟交换机上,相当于本机开了一个wifi,然后虚拟机连接wifi进行上网

  - 仅主机模式

    虚拟机和本机都使用虚拟网卡 VMnet1,这种连接造成虚拟机和本机都没有网络,只能两个机子进行通讯

linux的远程管理协议

---

linux使用的是SSH协议（Secure [Shell](http://c.biancheng.net/shell/)）

> SSH协议: 命令行界面远程管理协议，几乎所有操作系统都默认支持此协议。和 Telnet 不同，该协议在数据传输时会对数据进行加密并压缩，因此使用此协议传输数据既安全速度又快。

# 文件和目录

## 文件目录结构

整体结构图

![](.img/.linux/2-1Z5061A1003X.gif)

**根目录**

---

与系统的开机、修复、还原密切相关; 根目录必须包含开机软件、核心文件、开机所需程序、函数库、修复系统程序等文件

**一级目录**

---

- `/bin`: 存放系统命令
- `/boot`: 系统启动目录
- `/dev`: 设备文件保存位置
- `/etc`: 配置文件保存位置
- `/home`: 普通用户的主目录(也成为家目录),每个用户在家目录都会有一个和用户名相同的目录
- `/lib`: 系统调用的函数库保存位置
- `/media,/mnt,/misc`:挂载目录 ,挂载媒体设备
- `/opt`: 第三方安装的软件保存位置
- `/root`: root的主目录
- `/sbin`: 保存与系统环境相关的命令
- `/srv`: 服务数据目录; 一些系统服务启动之后，会在这个目录中保存所需要的数据
- `/tmp`: 临时目录; 系统存放临时文件的目录
- `/lost+found`: 当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里
- `/proc,/sys`: 虚拟文件系统; 该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等
- `/usr`: 此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 /usr 目录下的各子目录中，而不是为他们的产品创建单独的目录。
- `/var`: 用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。



详细介绍两个目录

**/usr目录**

---

Linux 系统中，所有系统默认的软件都存储在 /usr 目录下, /usr 目录类似 Windows 系统中 C:\Windows\ + C:\Program files\ 两个目录的综合体。

- `/usr/bin/`: 存放系统命令
- `/usr/sbin/`: 存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。
- `/usr/lib/`: 应用程序调用的函数库保存位置 
- `/usr/XllR6/`: 图形界面系统保存位置 
- `/usr/local/`: 手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置  
- `/usr/share/`: 应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录  
- `/usr/src/`: 源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里

**/var目录**

---

- `/var/lib/`: 程序运行中需要调用或改变的数据保存位置。如 MySQL 的数据库保存在 /var/lib/mysql/ 目录中  
- `/var/log/`: 登陆文件放置的目录，其中所包含比较重要的文件如 /var/log/messages, /var/log/wtmp 等。  
- `/var/run/`: 一些服务和程序运行后，它们的 PID（进程 ID）保存位置  
- `/var/spool/`: 里面主要都是一些临时存放，随时会被用户所调用的数据，例如 /var/spool/mail/ 存放新收到的邮件，/var/spool/cron/ 存放系统定时任务。  
- `/var/www/`: RPM 包安装的 Apache 的网页主目录  
- `/var/nis和/var/yp`  NIS `服务机制所使用的目录`，nis 主要记录所有网络中每一个 client 的连接信息；yp 是 linux 的 nis 服务的日志文件存放的目录  
- `/var/tmp`: 一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除

# linux基本命令

命令的基本格式

```cmd
[root@localhost ~]# 命令[选项][参数]
```

> - root：显示的是当前的登录用户
> - localhost：当前系统的简写主机名（完整主机名是 localhost.localdomain）。
> - ~：代表用户当前所在的目录，此例中用户当前所在的目录是家目录。
>   - 超级用户的家目录：/root。
>   - 普通用户的家目录：/home/用户名
> - \#：命令提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是 #；如果是普通用户，提示符就是 $。

总结一下：

命令的选项用于调整命令功能，而命令的参数是这个命令的操作对象

## cd

用来切换工作目录, 是 Change Directory 的缩写

基本格式

```cmd
[root@localhost ~]# cd [相对路径或绝对路径]
```

选项

- `~`: 代表当前登录用户的主目录  
- `~用户名`: 表示切换至指定用户的主目录  
- `-`: 代表上次所在目录  
- `.`: 代表当前目录  
- `..`: 代表上级目录

| 特殊符号 | 作 用                      |
| -------- | -------------------------- |
| ~        | 代表当前登录用户的主目录   |
| ~用户名  | 表示切换至指定用户的主目录 |
| -        | 代表上次所在目录           |
| .        | 代表当前目录               |
| ..       | 代表上级目录               |

## pwd

显示用户当前所处的工作目录, Print Working Directory （打印工作目录）的缩写

基本格式

```cmd
[root@localhost ~]# pwd
```

## ls

显示当前目录下的内容; list 的缩写

基本命令

```cmd
[root@localhost ~]# ls [选项] 目录名称
```

选项

- `-a`: 显示全部的文件，包括隐藏文件（开头为 . 的文件）
- `-h`: 以易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等。
- `-l`: 使用长格式列出文件和目录信息
- `-R`: 连同子目录内容一起列出来，递归显示目录
- `-t`: 以时间排序，而不是以文件名排序。

示例

```cmd
# 不加参数(默认当前路径)
[root@www ~]# ls -alh 
# 加上参数(路径)
[root@www ~]# ls -alh /
```

## mkdir

用于创建新目录, 是 make directories 的缩写

基本格式

```cmd
[root@localhost ~]# mkdir [-mp] 目录名
```

选项

- `-m`: 选项用于手动配置所创建目录的权限，而不再使用默认权限。
- `-p`: 选项递归创建所有目录，以创建 /home/test/demo 为例，在默认情况下，你需要一层一层的创建各个目录，而使用 -p 选项，则系统会自动帮你创建 /home、/home/test 以及 /home/test/demo。

示例

```cmd
# 使用 -p 选项递归建立目录
[root@localhost ~]# mkdir -p lm/movie/jp/cangls

# 使用 -m 选项自定义目录权限
[root@localhost ~]# mkdir -m 711 test2
```

## rmdir

用于删除空目录, 是remove empty directories 的缩写,

基本格式

```cmd
[root@localhost ~]# rmdir [-p] 目录名
```

选项

- `-p`: 用于递归删除空目录。

## touch

创建文件

基本格式

```cmd
[root@localhost ~]# touch [选项] 文件名
```

选项

- `-a`：只修改文件的访问时间；
- `-c`：仅修改文件的时间参数（3 个时间参数都改变），如果文件不存在，则不建立新文件。
- `-d`：后面可以跟欲修订的日期，而不用当前的日期，即把文件的 atime 和 mtime 时间改为指定的时间。
- `-m`：只修改文件的数据修改时间。
- `-t`：命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为 `YYMMDDhhmm`。

## ln

用于给文件创建链接

> - 软链接：类似于 Windows 系统中给文件创建快捷方式
> - 硬链接：指的就是给一个文件的 inode 分配多个文件名，通过任何一个文件名，都可以找到此文件的 inode，从而读取该文件的数据信息。

基本格式

```cmd
[root@localhost ~]# ln [选项] 源文件 目标文件
```

选项

- `-s`：建立软链接文件。如果不加 "-s" 选项，则建立硬链接文件；
- `-f`：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件；

示例

- 创建硬链接

  `ln /root/cangls /tmp`
  
- 创建软连接

  `ln -s /root/bols /tmp`

## cp

复制文件和目录

基本格式

```cmd
[root@localhost ~]# cp [选项] 源文件 目标文件
```

选项

- `-a`：相当于 -d、-p、-r 选项的集合
- `-d`：如果源文件为软链接（对硬链接无效），则复制出的目标文件也为软链接；
- `-p`：复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）；
- `-r`：递归复制，用于复制目录；
- `-u`：若目标文件比源文件有差异，则使用该选项可以更新目标文件，此选项可用于对文件的升级和备用。

示例

- 把源文件不改名复制到 /tmp/ 目录下

  `cp cangls /tmp/`

- 改名复制

  `cp cangls /tmp/bols`

## rm

删除命令

基本格式

```cmd
[root@localhost ~]# rm[选项] 文件或目录
```

选项

- `-f`：强制删除（force），和 -i 选项相反，使用 -f，系统将不再询问，而是直接删除目标文件或目录。
- `-i`：和 -f 正好相反，在删除文件或目录之前，系统会给出提示信息，使用 -i 可以有效防止不小心删除有用的文件或目录。
- `-r`：递归删除，主要用于删除目录，可删除指定目录及包含的所有内容，包括所有的子目录和文件。

示例

```cmd
#强制删除所有，一了百了
[root@localhost ~]# rm -rf /test
```

## mv

在不同的目录之间移动文件或目录, 也可以对文件和目录进行重命名; move 的缩写

基本格式

```cmd
[root@localhost ~]# mv 【选项】 源文件 目标文件
```

选项

- `-f`：强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖；
- `-i`：交互移动，如果目标文件已经存在，则询问用户是否覆盖（默认选项）；
- `-n`：如果目标文件已经存在，则不会覆盖移动，而且不询问用户；
- `-v`：显示文件或目录的移动过程；
- `-u`：若目标文件已经存在，但两者相比，源文件更新，则会对目标文件进行升级；

示例

- 移动目录(源文件删除)

  `mv cangls /tmp`

- 移动并强制覆盖目录

  `mv -f cangls /tmp`

- 修改名称(如果都在同一目录,移动就是改名)

  `mv bols lmls`

# 打包和压缩

打包是指将多个文件打包成一个文件,但是并不进行压缩

压缩是指将一个文件进行压缩,使之所占用的空间变小

## .tar和.tar.gz文件

`.tar`文件是打包非压缩文件,`.tar.gz`文件是打包且压缩文件

- **.tar文件**

  - 打包

    `tar -cvf ./test.tar test`

  - 解压

    `tar -xvf ./anaconda-ks.cfg.tar`

- **.tar.gz文件**

  - 打包并压缩

    `tar -zcvf ./tmp.tar.gz /tmp/`

  - 解压缩

    `tar -zxvf ./tmp.tar.gz`

## .zip文件

- **压缩文件命令**

  基本格式

  ```cmd
  [root@localhost ~]#zip [选项] 压缩包名 源文件或源目录列表
  ```

  选项

  - `-v`: 显示详细的压缩过程信息。  
  - `-r`: 递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。  

  示例

  - 压缩多个文件

    `zip -v test.zip install.log install.log.syslog`

  - 压缩目录

    `zip -vr dir1.zip dir1`

- **解压缩文件命令**

  基本格式

  ```cmd
  [root@localhost ~]# unzip [选项] 压缩包名
  ```

  选项

  - `-d 目录名`: 将压缩文件解压到指定目录下。
  - `-o`: 解压时覆盖已经存在的文件，并且无需用户确认。

  示例

  - 解压到当前目录

    `unzip -d ./ ana.zip`

# Vim文本编辑器

## 介绍及其安装

Vim 是一个基于文本界面的编辑工具，使用简单且功能强大。

vim的安装

```cmd
yum -y install vim
```

## 三种工作模式

- 命令模式

  默认处于命令模式,可以使用方向键,可以对文件内容及进行复制,复制、粘贴、替换、删除等操作。

- 输入模式

  可以键入文本

- 编辑模式

  可以执行保存,查找或替换等操作

  按`:`即可进入到编辑模式,退出按`ESC`

## 基本操作

### 打开文件

`vim /test/vi.test`

### 插入文本

- 在当前光标所在位置输入文本

  `i`

- 在光标所在行的下面插入新的一行

  `o`

- 在光标所在行的行尾输入文本

  `A`

### 查找文本

- 从光标所在位置向前查找字符串abc

  `:/abc`

- 从光标所在位置向后查找字符串abc

  `:?abc`

- 查找以abc为首的行

  `:/^abc`

### 替换文本

- 替换`当前行`的`第一个` vivian 为 sky 

  `:s/vivian/sky/`

- 替换`当前行`的`所有的` vivian 为 sky 

  `:s/vivian/sky/g`

- 替换`每一行`的`第一个` vivian 为 sky 

  `:%s/vivian/sky/`

- 替换`每一行`的`所有的` vivian 为 sky 

  `:%s/vivian/sky/g`

### 删除文本

删除掉的文本会存放在剪贴板中

- 删除光标所在行

  `dd`

- 删除光标位置到行尾的内容

  `D`

### 复制文本

- 将剪贴板中的内容复制到光标后

  `p`

- 将光标所在行复制到剪贴板

  `yy`

### 撤销操作

`u`

### 保存退出文本

- 保存并退出

  `:wq`

- 保存并强制退出

  `:wq!`

- 不保存退出

  `q`

- 不保存强制退出

  `q!`

### 光标移动

- 移动到文件开头

  `gg`

- 移动到文件末尾

  `G`

- 移动到指定行

  `nG`, n为行数

# 文本处理命令

在 Linux 中，文本处理无非是对文本内容做查看、修改等操作。本章将介绍Linux中常用的文本处理命令，以及被称为Linux三剑客的 `grep`、`sed` 和 `awk` 命令。

## cat

快速查看文本的全部内容(因此cat 命令适合查看不太大的文件),也可以进行合并文件

示例

- 查看文件

  `cat a.txt`

- 合并文件

  `cat a.txt b.txt > c.txt`

## more

可以分页显示文本文件的内容

示例

- 基本操作

  `more anaconda-ks.cfg`

- 从第 n 行开始显示文件内容，n 代表数字

  `more +n anaconda-ks.cfg`

交互命令

- 退出文件查看

  `q`

- 向下移动一行

  `回车键`

- 向下移动一页

  `空格键`

- 向上移动半页

  `d`

- 向上移动一页

  `b`

## less

可以分页显示文本文件的内容,和more命令的功能相似,但是更加强大

示例

- 基本操作

  `less /boot/grub/grub.cfg`

- 显示百分比

  `less -m /boot/grub/grub.cfg`

交互命令

> 要先输入一个`:`

- 向上移动一页

  `【PgUp】键`

- 向下移动一页

  `【PgDn】键`

- 向下移动一行

  `j`

- 向上移动一行

  `k`

- 移动至最后一行

  `G`

- 移动到第一行

  `g`

- 向下搜索“字符串”

  `/字符串`

- 向上搜索“字符串”

  `?字符串`

- 退出 less 命令

  `ZZ`

## head

查看文件前几行的内容

示例

- 查看前20行的内容

  `head -n 20 anaconda-ks.cfg`

## tail

查看文件后几行的内容

示例

- 查看文件后3行的内容

  `tail -n 3 /etc/passwd`

- 监听文件变动,并实时显示

  `tail -f anaconda-ks.cfg`

## grep

从文件中找到包含指定信息的那些行,支持正则表达式

基本格式

```cmd
[root@localhost ~]# grep [选项] 模式 文件名
```

选项

| 选项 | 含义                                                       |
| ---- | ---------------------------------------------------------- |
| `-c` | 仅列出文件中`包含模式的行数`。                             |
| `-i` | 忽略模式中的字母大小写。                                   |
| `-l` | 列出带有匹配行的文件名。                                   |
| `-n` | 在每一行的最前面列出行号。                                 |
| `-v` | 列出没有匹配模式的行。                                     |
| `-w` | 把表达式当做一个完整的单字符来搜寻，忽略那些部分匹配的行。 |

示例

- 例1

  假设有一份 emp.data 员工清单，现在要搜索此文件，找出职位为 CLERK 的所有员工，则执行命令如下：

  ```cmd
  [root@localhost ~]# grep CLERK emp.data
  #忽略输出内容
  ```

  而在此基础上，如果只想知道职位为 CLERK 的员工的人数，可以使用“`-c`”选项，执行命令如下：

  ```cmd
  [root@localhost ~]# grep -c CLERK emp.data
  #忽略输出内容
  ```

- 例2

  搜索 emp.data 文件，使用正则表达式找出以 78 开头的数据行，执行命令如下：

  ```cmd
  [root@localhost ~]# grep ^78 emp.data
  #忽略输出内容
  ```

  > **正则表达式**是描述一组字符串的一个模式，正则表达式的构成模仿了数学表达式，通过使用操作符将较小的表达式组合成一个新的表达式。正则表达式可以是一些纯文本文字，也可以是用来产生模式的一些特殊字符。为了进一步定义一个搜索模式，grep 命令支持如表  所示的这几种正则表达式的元字符（也就是通配符）。
  >
  > | 通配符   | 功能                                                |
  > | -------- | --------------------------------------------------- |
  > | `c*`     | 将匹配 0 个（即空白）或多个字符 c（c 为任一字符）。 |
  > | `.`      | 将匹配任何一个字符，且只能是一个字符。              |
  > | `[xyz]`  | 匹配方括号中的任意一个字符。                        |
  > | `[^xyz]` | 匹配除方括号中字符外的所有字符。                    |
  > | `^`      | 锁定行的开头。                                      |
  > | `$`      | 锁定行的结尾。                                      |
  >
  > > 需要注意的是，在基本正则表达式中，如通配符 *、+、{、|、( 和 )等，已经失去了它们原本的含义，而若要恢复它们原本的含义，则要在之前添加反斜杠 \，如 \*、\+、\{、\|、\( 和 \)。

# rpm和yum

linux的安装包

- 源码包

  源码包就是一大堆源代码程序,还未进行编译,所以安装的时候需要先编译后安装

- 二进制包

  二进制包就是编译好的文件,可以直接进行安装; 这也是linux下默认的软件安装包

  主流的二进制包管理系统：rpm

  > RPM 包管理系统：功能强大，安装、升级、査询和卸载非常简单方便

## rpm包的命令规则

命令的一般格式

```cmd
包名-版本号-发布次数-发行商-Linux平台-适合的硬件平台-包扩展名
```

示例

> RPM 包的名称是`httpd-2.2.15-15.el6.centos.1.i686.rpm`

- httped：软件包名。这里需要注意，httped 是包名，而 httpd-2.2.15-15.el6.centos.1.i686.rpm 通常称为包全名，包名和包全名是不同的，在某些 Linux 命令中，有些命令（如包的安装和升级）使用的是包全名，而有些命令（包的查询和卸载）使用的是包名，一不小心就会弄错。

- 2.2.15：包的版本号，版本号的格式通常为`主版本号.次版本号.修正号`。

- 15：二进制包发布的次数，表示此 RPM 包是第几次编程生成的。

- el*：软件发行商，el6 表示此包是由 Red Hat 公司发布，适合在 RHEL 6.x (Red Hat Enterprise Unux) 和 CentOS 6.x 上使用。

- centos：表示此包适用于 CentOS 系统。

- i686：表示此包使用的硬件平台

- rpm：RPM 包的扩展名，表明这是编译好的二进制包，可以使用 rpm 命令直接安装。此外，还有以 src.rpm 作为扩展名的 RPM 包，这表明是源代码包，需要安装生成源码，然后对其编译并生成 rpm 格式的包，最后才能使用 rpm 命令进行安装。

## rpm包管理软件

### 安装软件

命令格式

```cmd
[root@localhost ~]# rpm -ivh 包全名
```

选项

- -i：安装（install）;
- -v：显示更详细的信息（verbose）;
- -h：打印 #，显示安装进度（hash）;

示例

- 安装apache

  `rpm -ivh /mnt/cdrom/Packages/httpd-2.2.15-15.el6.centos.1.i686.rpm`

- 一次性安装多个安装包

  `rpm -ivh a.rpm b.rpm c.rpm`

默认的安装路径

| 安装路径          | 含 义                      |
| ----------------- | -------------------------- |
| `/etc/`           | 配置文件安装目录           |
| `/usr/bin/`       | 可执行的命令安装目录       |
| `/usr/lib/`       | 程序所使用的函数库保存位置 |
| `/usr/share/doc/` | 基本的软件使用手册保存位置 |
| `/usr/share/man/` | 帮助文件保存位置           |

### 操作软件

命令格式

```cmd
[root@localhost ~]# service 服务名 start|stop|restart|status
```

参数含义

- start：启动服务；
- stop：停止服务；
- restart：重启服务；
- status: 查看服务状态；

示例

- 启动apache

  `service httpd start `

### 升级软件

命令格式

```cmd
[root@localhost ~]# rpm -Uvh 包全名
```

### 卸载软件

命令格式

```cmd
[root@localhost ~]# rpm -e 包名
```

注意事项

- 在卸载软件时,需要先卸载依赖的包,才能卸载该软件

### 查询软件信息

- 查询是否安装

  命令格式

  ```cmd
  [root@localhost ~]# rpm -q 包名
  ```

  > 注意这里使用的是包名，而不是包全名。

  示例

  - 查看是否安装 apache

    `rpm -q httpd`

- 查询所有安装的软件

   示例

  - 基本使用

    `rpm -qa`

  - 使用管道符过滤

    `rpm -qa | grep httpd`

- 查询软件的详细信息

  基本格式

  ```cmd
  [root@localhost ~]# rpm -qi 包名
  ```

  示例

  - 查询apache的详细信息

    `rpm -qi httpd`

- 查询未安装软件的信息

  命令格式

  ```cmd
  [root@localhost ~]# rpm -qip 包全名
  ```

### 查询软件的文件路径

查询已安装软件包中包含的所有文件及各自安装路径

- 查看已安装软件的文件路径

  命令格式

  ```cmd
  [root@localhost ~]# rpm -ql 包名
  ```

  示例

  - 查看apache的所有文件安装路径

    `rpm -ql httpd`

- 查看未安装软件的预安装路径

  命令格式

  ```cmd
  [root@localhost ~]# rpm -qlp 包全名
  ```

  示例

  - 查看bing软件包(未安装)

    `rpm -qlp /mnt/cdrom/Packages/bind-9.8.2-0.10.rc1.el6.i686.rpm`

### 查询文件属于哪个软件

rpm 支持反向查询，即查询某系统文件所属哪个 RPM 软件包

命令格式

```cmd
[root@localhost ~]# rpm -qf 系统文件名
```

示例

- 查询ls命令所属的软件包

  `rpm -qf /bin/ls`

## yum源及配置

yum是一种可自动安装软件包（自动解决包之间依赖关系）的安装方式

- 查看yum是否已安装

  `rpm -qa | grep yum`

  [如果没有安装yum,可以使用rpm进行安装yum](https://jingyan.baidu.com/article/e3c78d6483a02a3c4d85f578.html)

设置yum源

> yum 源指的就是软件安装包的来源。

- 网络yum源

  网络 yum 源配置文件位于 /etc/yum.repos.d/ 目录下，文件扩展名为"*.repo"（只要扩展名为 "*.repo" 的文件都是 yum 源的配置文件）。通常情况下 CentOS-Base.repo 文件生效

  打开CentOS-Base.repo文件

  ```cmd
  [root@localhost yum.repos.d]# vim /etc/yum.repos.d/ CentOS-Base.repo
  [base]
  name=CentOS-$releasever - Base
  mirrorlist=http://mirrorlist.centos.org/? release= $releasever&arch=$basearch&repo=os
  baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
  gpgcheck=1
  gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
  …省略部分输出…
  ```

  参数含义

  - [base]：容器名称，一定要放在[]中。
  - name：容器说明，可以自己随便写。
  - mirrorlist：镜像站点，这个可以注释掉。
  - baseurl：我们的 yum 源服务器的地址。默认是 CentOS 官方的 yum 源服务器，是可以使用的。如果你觉得慢，则可以改成你喜欢的 yum 源地址。
  - enabled：此容器是否生效，如果不写或写成 enabled 则表示此容器生效，写成 enable=0 则表示此容器不生效。
  - gpgcheck：如果为 1 则表示 RPM 的数字证书生效；如果为 0 则表示 RPM 的数字证书不生效。
  - gpgkey：数字证书的公钥文件保存位置。不用修改。

- 本地yum源

  在无法联网的情况下，yum 可以在本地直接安装映像文件

  用到再参考网上教程

## yum基本命令

### 安装软件

`yum -y install 包名`

示例

- 安装gcc

  `yum -y install gcc`

### 升级软件

示例

- 升级所有软件包

  `yum -y update`

- 升级对应软件

  `yum -y update 包名`

### 卸载软件

> 使用yum进行卸载会把卸载软件依赖的所有包都会卸载掉,所以要谨慎使用

` yum remove 包名`

### 其他操作

- 查询所有已安装软件

  `yum list`

- 查询对应软件

  `yum list 包名`

- 从yum源服务器上查询软件包

  `yum search 关键字`

- 查询软件包的详细信息

  `yum info 包名`

# 用户和用户组管理

## 原理和文件解释

**用户**

- 每个用户都有唯一的用户名和密码。在登录系统时，只有正确输入用户名和密码，才能进入系统和自己的主目录。

**用户组**

- 用户组是具有相同特征用户的逻辑集合
- 在同一个用户组里的用户都具有该用户组所持有的权限

**两者关系**

1. 一对一：一个用户可以存在一个组中，是组中的唯一成员；
2. 一对多：一个用户可以存在多个用户组中，此用户具有这多个组的共同权限；
3. 多对一：多个用户可以存在一个组中，这些用户具有和组相同的权限；
4. 多对多：多个用户可以存在多个组中，也就是以上 3 种关系的扩展。

**用户ID(UID)和用户组ID(GID)**

- 所有用户的名称与 ID 的对应关系都存储在 /etc/passwd 文件中

  > 说白了，用户名并无实际作用，仅是为了方便用户的记忆而已。

- 在 /etc/passwd 文件中，利用 UID 可以找到对应的用户名；在 /etc/group 文件中，利用 GID 可以找到对应的群组名。

**/etc/passwd内容解释**

- 是系统用户配置文件，存储了系统中所有用户的基本信息

  内容如下

  ```cmd
  [root@localhost ~]# vi /etc/passwd
  #查看一下文件内容
  root:x:0:0:root:/root:/bin/bash
  bin:x:1:1:bin:/bin:/sbin/nologin
  daemon:x:2:2:daemon:/sbin:/sbin/nologin
  adm:x:3:4:adm:/var/adm:/sbin/nologin
  ...省略部分输出...
  ```

  每行用户信息都以 "：" 作为分隔符，划分为 7 个字段，每个字段所表示的含义如下：

  >  用户名：密码：UID（用户ID）：GID（组ID）：描述性信息：主目录：默认Shell

  - 用户名: 一串代表用户身份的字符串,方便用户记忆

  - 密码: "x" 表示此用户设有密码，但不是真正的密码，真正的密码保存在 `/etc/shadow` 文件中

  - UID: 用户 ID

  - GID: 用户初始组的组 ID 

    > 初始组指用户登陆时就拥有这个用户组的相关权限

  - 描述性信息: 不重要

  - 主目录: 用户登录后有操作权限的访问目录

  - 默认shell: 我也不知道

**/etc/shadow内容解析**

- 用于存储 Linux 系统中用户的密码信息

  /etc/shadow 文件只有 root 用户拥有读权限，其他用户没有任何权限，这样就保证了用户密码的安全性。

  文件内容

  ```cmd
  [root@localhost ~]#vim /etc/shadow
  root: $6$9w5Td6lg
  $bgpsy3olsq9WwWvS5Sst2W3ZiJpuCGDY.4w4MRk3ob/i85fl38RH15wzVoom ff9isV1 PzdcXmixzhnMVhMxbvO:15775:0:99999:7:::
  bin:*:15513:0:99999:7:::
  daemon:*:15513:0:99999:7:::
  …省略部分输出…
  ```

  文件中每行代表一个用户，同样使用 ":" 作为分隔符，不同之处在于，每行用户信息被划分为 9 个字段

  `用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段`

  每个字段含义如下:

  - 用户名: 一串好记忆的字符
  - 加密密码: 这里保存的是真正加密的密码, 采用的是 SHA512 散列加密算法
  - 最后一次修改时间: 计算日期的时间是以  1970 年 1 月 1 日作为 1 不断累加得到的时间
  - 最小修改时间间隔: 如果是 0，则密码可以随时修改；如果是 10，则代表密码修改后 10 天之内不能再次修改密码
  - 密码有效期: 该字段的默认值为 99999，也就是 273 年，可认为是永久生效。如果改为 90，则表示密码被修改 90 天之后必须再次修改，否则该用户即将过期。
  - 密码需要变更前的警告天数: 该字段的默认值是 7
  - 密码过期后的宽限天数: 此字段规定的宽限天数是 10，则代表密码过期 10 天后失效；如果是 0，则代表密码过期后立即失效；如果是 -1，则代表密码永远不会失效。
  - 账号失效时间: ...
  - 保留: ...
  - 忘记密码怎么办: 对于普通账户可以通过 root 账户重置密码; 如果 root 账号的密码遗失，则需要重新启动进入单用户模式，系统会提供 root 权限的 bash 接口，此时可以用 passwd 命令修改账户密码；

**/etc/group文件解析**

- 是用户组配置文件，即用户组的所有信息都存放在此文件中。

  此文件是记录组 ID（GID）和组名相对应的文件

  文件内容

  ```cmd
  [root@localhost ~]#vim /etc/group
  root:x:0:
  bin:x:1:bin,daemon
  daemon:x:2:bin,daemon
  …省略部分输出…
  lamp:x:502:
  ```

  各用户组中，还是以 "：" 作为字段之间的分隔符，分为 4 个字段

  `组名：密码：GID：该用户组中的用户列表`

  每个字段对应的含义为：

  - 组名: 用户组的名称
  - 组密码:  "x" 仅仅是密码标识，真正加密后的组密码默认保存在 /etc/gshadow 文件中
  - 组ID(GID): 群组的 ID 号
  - 组中的用户: 此字段列出每个群组包含的所有用户

**用户和用户组的关系的总结**

- 到此，我们已经学习了/etc/passwd、/etc/shadow、/etc/group，它们之间的关系可以这样理解，即先在 /etc/group 文件中查询用户组的 GID 和组名；然后在 /etc/passwd 文件中查找该 GID 是哪个用户的初始组，同时提取这个用户的用户名和 UID；最后通过 UID 到 /etc/shadow 文件中提取和这个用户相匹配的密码。

**/ect/gshadow文件内容解析**

- 组用户信息存储在 /etc/group 文件中，而`将组用户的密码信息存储在 /etc/gshadow 文件中`。

  文件内容

  ```cmd
  [root@localhost ~]#vim /etc/gshadow
  root:::
  bin:::bin, daemon
  daemon:::bin, daemon
  ...省略部分输出...
  lamp:!::
  ```

  文件中，每行代表一个组用户的密码信息，各行信息用 ":" 作为分隔符分为 4 个字段，每个字段的含义如下：

  `组名：加密密码：组管理员：组附加用户列表`

  字段的具体含义

  - 组名

    同 /etc/group 文件中的组名相对应。

  - 组密码

    对于大多数用户来说，通常不设置组密码，因此该字段常为空，但有时为 "!"，指的是该群组没有组密码，也不设有群组管理员。

  - 组管理员

    从系统管理员的角度来说，该文件最大的功能就是创建群组管理员。

    考虑到 Linux 系统中账号太多，而超级管理员 root 可能比较忙碌，因此当有用户想要加入某群组时，root 或许不能及时作出回应。这种情况下，如果有群组管理员，那么他就能将用户加入自己管理的群组中，也就免去麻烦 root 了。

    不过，由于目前有 sudo 之类的工具，因此群组管理员的这个功能已经很少使用了。

  - 组中的附加用户

    该字段显示这个用户组中有哪些附加用户，和 /etc/group 文件中附加组显示内容相同

**/ect/login.defs(创建用户的默认设置文件)**

- 对用户的一些基本属性做默认设置

## 常用操作命令

### useradd

添加新的系统用户

- 创建用户的原理

  > 系统首先读取 /etc/login.defs 和 /etc/default/useradd，根据这两个配置文件中定义的规则添加用户，也就是向 /etc/passwd、/etc/group、/etc/shadow、/etc/gshadow 文件中添加用户数据，接着系统会自动在 /etc/default/useradd 文件设定的目录下建立用户主目录，最后复制 /etc/skel 目录中的所有文件到此主目录中，由此，一个新的用户就创建完成了。

- 命令格式

  `useradd [选项] 用户名`

- 示例

  - 创建lamp普通用户

    `useradd lamp`

  - 在建立用户lamp1的同时，指定了UID（550）、初始组（lamp1）、附加组（root）、家目录（/home/lamp1/）、用户说明（test user）和用户登录Shell（/bin/bash）

    `useradd -u 550 -g lamp1 -G root -d /home/lamp1 -c "test user" -s /bin/bash lamp1`

### passwd

修改用户密码

- 命令格式

  ```cmd
  [root@localhost ~]# passwd [选项] 用户名
  ```

- 示例

  - 使用 root 账户修改 lamp 普通用户的密码

    `passwd lamp`

  - 修改当前系统已登入用户的密码

    `passwd`

### usermod

修改用户信息

- 命令格式

  ```
  [root@localhost ~]# usermod [选项] 用户名
  ```

- 示例

  - 锁定用户

    `usermod -L lamp`

  - 解锁用户

    `usermod -U lamp`

  - 把用户加入root组

    `usermod -G root lamp`

  - 修改用户说明

    `usermod -c "test user" lamp `

### chage

修改用户密码状态

- 







### userdel

删除用户

### id

查看用户的UID和GID

### su

用户间切换

### groupadd

修改用户组

### groupdel

删除用户组

### gpasswd

把用户添加进组或从组中删除

### newgrp

切换用户的有效组

