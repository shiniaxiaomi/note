## 大纲

数据结构：

- **链表**

- **栈**

- **队列**

- **二叉树**（三种遍历，查找树，堆排序，最小堆）

- 图

  - [弗洛伊德最短路径算法](https://blog.csdn.net/rebornyp/article/details/81453251?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase#34-弗洛伊德最短路径算法)
  - [Dijkstra最短路径算法](https://blog.csdn.net/rebornyp/article/details/81453251?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase#35-dijkstra最短路径算法)

  - 最小生成树



算法：

- 排序

  - **插入排序**
  - **冒泡排序**
  - **归并排序**
  - 快速排序
  - 堆排序

- 普通算法

  https://blog.csdn.net/dcj0913/article/details/39271721

  - **回溯**（深度优先） 
  - **分治算法**
  - **分支限界算法**（广度优先，并限定界限）
  - 动态规划
  - 贪心算法

## 数据结构

### 链表

直接使用java中的LinkedList类即可

### 栈

- 不推荐：直接使用java中的Stack类即可（线程安全的，效率不高）

- 不推荐：直接使用java中的LinkedList类也可以当作栈来使用，效率比Stack类要高（因为没有同步），底层采用了链表的结构
- 推荐：使用ArrayDeque来做栈，因为没有同步，而且底层采用了数组的结构

### 队列

- ArrayDeque：双端队列
- PriorityQueue：优先队列（底层采用的是数组堆）

### 二叉树

二叉树可以实现堆，也可以使用数据来实现堆

- PriorityQueue：优先队列(数组堆)

### 图

- 稀疏图（数据+链表）
- 稠密图（数组）



## 算法

### 排序

#### 冒泡排序

原理：

- 比较两个相邻的元素，将值大的元素交换到右边。
- 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样，最后的元素应该会是最大的数。
- 针对所有的元素重复以上的步骤，除了最后一个。
- 持续重复上面的步骤，直到没有任何一对元素需要比较。

#### 插入排序

原理：

- 对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量k来记住他的位置，接着第二次比较，前面“后一个元素”现变成了“前一个元素”，继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量k记住它在数组中的位置(下标)，等到循环结束的时候，我们应该找到了最小的那个数的下标了，然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了。
- 以此类推，重复上面步骤找第二小的数，第三小的数。。。





#### 归并排序

原理：



#### 堆排序

原理：





### 普通



#### 回溯算法



#### 分支限界算法



#### 分治算法



#### 动态规划



#### 贪心算法









